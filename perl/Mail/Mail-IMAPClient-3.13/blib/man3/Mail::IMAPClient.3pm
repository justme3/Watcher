.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::IMAPClient 3"
.TH Mail::IMAPClient 3 "2008-04-28" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Mail::IMAPClient \- An IMAP Client API
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides methods implementing the \s-1IMAP\s0 protocol. It allows
perl scripts to interact with \s-1IMAP\s0 message stores.
.PP
The module is used by constructing or instantiating a new IMAPClient
object via the new constructor method. Once the object has been
instantiated, the connect method is either implicitly or explicitly
called. At that point methods are available that implement the \s-1IMAP\s0
client commands as specified in \fI\s-1RFC2060\s0\fR. When processing is
complete, the \fIlogoff\fR object method should be called.
.PP
This documentation is not meant to be a replacement for \s-1RFC2060\s0, and
the wily programmer will have a copy of that document handy when coding
\&\s-1IMAP\s0 clients. 
.PP
Note that this documentation uses the term \fIfolder\fR in place of
\&\s-1RFC2060\s0's use of \fImailbox\fR. This documentation reserves the use of the
term \fImailbox\fR to refer to the set of folders owned by a specific \s-1IMAP\s0
id.
.PP
\&\s-1RFC2060\s0 defines four possible states for an \s-1IMAP\s0 connection: not
authenticated, authenticated, selected, and logged out. These
correspond to the \fBIMAPClient\fR constants \f(CW\*(C`Connected\*(C'\fR,
\&\f(CW\*(C`Authenticated\*(C'\fR, \f(CW\*(C`Selected\*(C'\fR, and \f(CW\*(C`Unconnected\*(C'\fR, respectively. These
constants are implemented as class methods, and can be used in
conjunction with the Status method to determine the status of an
\&\fBIMAPClient\fR object and its underlying \s-1IMAP\s0 session. Note that an
\&\fBIMAPClient\fR object can be in the \f(CW\*(C`Unconnected\*(C'\fR state both before a
server connection is made and after it has ended. This differs slightly
from \s-1RFC2060\s0, which does not define a pre-connection status. For a
discussion of the methods available for examining the \fBIMAPClient\fR
object's status, see the section labeled \*(L"Status Methods\*(R", below.
.Sh "Advanced Authentication Mechanisms"
.IX Subsection "Advanced Authentication Mechanisms"
\&\s-1RFC2060\s0 defines two commands for authenticating to an \s-1IMAP\s0 server:
\&\s-1LOGIN\s0 for plain text authentication and \s-1AUTHENTICATE\s0 for more secure
authentication mechanisms. Currently Mail::IMAPClient supports
\&\s-1DIGEST\-MD5\s0, \s-1CRAM\-MD5\s0, \s-1LOGIN\s0, \s-1PLAIN\s0 (\s-1SASL\s0), and \s-1NTLM\s0 authentication.
.PP
There are also a number of methods and parameters that you can use to
build your own authentication mechanism. Since this topic is a source of
many questions, I will provide a quick overview here. All of the methods
and parameters discussed here are described in more detail elsewhere in
this document; this section is meant to help you get started.
.PP
First of all, if you just want to do plain text authentication and
your server is okay with that idea then you don't even need to read
this section.
.PP
Second of all, the intent of this section is to help you implement the
authentication mechanism of your choice, but you will have to understand
how that mechanism works.  There are \fIlots\fR of authentication mechanisms
and most of them are not available to me to test with for one reason or
another. Even if this section does not answer all of your authentication
questions it \fIdoes\fR contain all the answers that I have, which I admit
are scant.
.PP
Third of all, if you manage to get any advanced authentication mechanisms
to work then please consider donating them to this module. I don't quite
have a framework visualized for how different authentication mechanisms
could \*(L"plug in\*(R" to this module but I would like to eventually see this
module distributed with a number of helper modules to implement various
authentication schemes.
.PP
The \fBMail::IMAPClient\fR's support for add-on authentication mechanisms is
pretty straight forward and is built upon several assumptions. Basically
you create a callback to be used to provide the response to the server's
challenge. The \fIAuthcallback\fR parameter contains a reference to the
callback, which  can be an anonymous subroutine or a named subroutine.
Then, you identify your authentication mechanism, either via the
\&\fIAuthmechanism\fR parameter or as an argument to authenticate.
.PP
You may also need to provide a subroutine to encrypt (or whatever) data
before it is sent to the server. The \fIPrewritemethod\fR parameter must
contain a reference to this subroutine.  And, you will need to decrypt
data from the server; a reference to the subroutine that does this must
be stored in the \fIReadmethod\fR parameter.
.PP
This framework is based on the assumptions that a) the mechanism you are
using requires a challenge-response exchange, and b) the mechanism does
not fundamentally alter the exchange between client and server but merely
wraps the exchange in a layer of encryption. It particularly assumes
that the line-oriented nature of the \s-1IMAP\s0 conversation is preserved;
authentication mechanisms that break up messages into blocks of a
predetermined size may still be possible but will certainly be more
difficult to implement.
.PP
Alternatively, if you have access to \fBimtest\fR, a utility included in
the Cyrus \s-1IMAP\s0 distribution, you can use that utility to broker your
communications with the \s-1IMAP\s0 server.  This is quite easy to implement. An
example, \*(L"imtestExample.pl\*(R" in examples, can be found in the \f(CW\*(C`examples\*(C'\fR
subdirectory of the source distribution.
.PP
The following list summarizes the methods and parameters that you may
find useful in implementing advanced autentication:
.IP "authenticate method" 4
.IX Item "authenticate method"
This method implements the \s-1AUTHENTICATE\s0 \s-1IMAP\s0 client command as documented
in \s-1RFC2060\s0.  If you have set the \fIAuthmechanism\fR parameter then the
login method will call authenticate instead of doing a clear text
login, which is its normal behavior.  If you don't want \fBlogin\fR to call
\&\fBauthenticate\fR on your behalf then you can call it yourself. Instead
of setting an \fIAuthmechanism\fR you can just pass the authmechanism as
the first argument to \s-1AUTHENTICATE\s0.
.IP "Socket and RawSocket Parameters" 4
.IX Item "Socket and RawSocket Parameters"
Both parameters hold a reference to the socket connection.  Normally this
is set for you by the connect method, but if you are implementing
an advanced authentication technique you may choose to set up your own
socket connection and then set this parameter manually, bypassing the
\&\fBconnect\fR method completely.  This is also useful if you want to use
IO::Socket::INET alternatives, like IO::Socket::SSL.
.Sp
The \fIRawSocket\fR parameter simply records the socket to use for future
operations, without attempting any interaction on it. In this case, you
have to be sure to handle all the preliminar operations and to manually
set the \fBMail::IMAPClient\fR object in sync with its actual status with
respect to this socket (see below for additional parameters regarding
this, especially the \fIState\fR parameter).
.Sp
The \fISocket\fR parameter, instead, also attempts to carry on preliminar
phases if the conditions apply. If both parameters are present, this
takes the precedence over \fIRawSocket\fR. It is primarily used to
provide an alternative socket for communications, e.g. to use
IO::Socket::SSL instead of IO::Socket::INET used by connect
by default.
.Sp
\&\fB\s-1PLEASE\s0 \s-1NOTE\s0\fR
As of version 2.99_04 of this module, the \fISocket\fR parameter has
changed semantics to make it more \*(L"\s-1DWIM\s0\*(R". The \fIRawSocket\fR parameter was
introduced as a replacement for the \fISocket\fR parameter in older version.
.IP "State, Server, Proxy, Password, User, Domain Parameters" 4
.IX Item "State, Server, Proxy, Password, User, Domain Parameters"
If you need to make your own connection to the server and perform your
authentication manually, then you can set these parameters to keep your
\&\fBMail::IMAPClient\fR object in sync with its actual status. Of these,
only the \fIState\fR parameter is always necessary.  The others need to be
set only if you think your program will need them later.
.Sp
\&\fIProxy\fR is required for \s-1PLAIN\s0 (\s-1SASL\s0) authentication.  \fIDomain\fR for \s-1NTLM\s0.
.IP "Authmechanism" 4
.IX Item "Authmechanism"
Set this to the value that \s-1AUTHENTICATE\s0 should send to the server as the
authentication mechanism. If you are brokering your own authentication
then this parameter may be less useful. It is also not needed by the
authenticate method. It exists solely so that you can set it when
you call new to instantiate your object. The \fBnew\fR method will
call connect, who will call login. If \fBlogin\fR sees that you've
set an \fIAuthmechanism\fR then it will call \fBauthenticate\fR, using your
\&\fIAuthmechanism\fR and \fIAuthcallback\fR parameters as arguments.
.IP "Authuser" 4
.IX Item "Authuser"
Normally you authenticate and log in with the username specified in
the User parameter. When you are using \s-1DIGEST\-MD5\s0 as \fIAuthmechanism\fR,
you can optionally specify a different username for the final log in.
This can be useful to mark messages as seen for the \fIAuthuser\fR
if you don't know the password of the user as the seen state
is often a per-user state.
.IP "Authcallback" 4
.IX Item "Authcallback"
The \fIAuthcallback\fR parameter, if set, should contain a pointer
to a subroutine. The login method will use this as the callback
argument to the \fBauthenticate\fR method if the \fIAuthmechanism\fR and
\&\fIAuthcallback\fR parameters are both set. If you set \fIAuthmechanism\fR
but not \fIAuthcallback\fR then the default callback for your mechanism will
be used.  All supported authentication mechanisms have a default callback;
in every other case not supplying the callback results in an error.
.Sp
Most advanced authentication mechanisms require a challenge-response
exchange. After the authenticate method sends \*(L"<tag> \s-1AUTHENTICATE\s0
<Authmechanism>\er\en\*(R"  to the \s-1IMAP\s0 server, the server replies with
a challenge. The \fBauthenticate\fR method then invokes the code whose
reference is stored in the \fIAuthcallback\fR parameter as follows:
.Sp
.Vb 1
\&        $Authcallback->($challenge,$imap)
.Ve
.Sp
where \f(CW$Authcallback\fR is the code reference stored in the \fIAuthcallback\fR
parameter, \f(CW$challenge\fR is the challenge received from the \s-1IMAP\s0 server,
and \f(CW$imap\fR is a pointer to the \fBMail::IMAPClient\fR object. The return
value from the \fIAuthcallback\fR routine should be the response to the
challenge, and that return value will be sent by the authenticate
method to the server.
.IP "Readmethod" 4
.IX Item "Readmethod"
The \fIReadmethod\fR parameter points to a routine that will read data from
the socket connection. This read method will replace the \fBsysread\fR that
would otherwise be performed by \fBMail::IMAPClient\fR. The replacement
method is called with five arguments. The first is a pointer to the
\&\fBMail::IMAPClient\fR object; the rest are the four arguments required by
the \fBsysread\fR function. Note the third argument (which corresponds to
the second argument to \fBsysread\fR) is a buffer to read into; this will
be a pointer to a scalar. So for example if your \fIReadmethod\fR were
just going to replace \fBsysread\fR without any intervening processing
(which would be silly but this is just an example after all) then you
would set your \fIReadmethod\fR like this:
.Sp
.Vb 7
\&        $imap->Readmethod( 
\&                sub { 
\&                        my($self) = shift; 
\&                        my($handle,$buffer,$count,$offset) = @_;
\&                        return sysread( $handle, $$buffer, $count, $offset);
\&                }
\&        );
.Ve
.Sp
Note particularly the double dollar signs in \f(CW$$buffer\fR in the \fBsysread\fR
call; this is not a typo!
.IP "Prewritemethod" 4
.IX Item "Prewritemethod"
The \fIPrewritemethod\fR, if defined, should contain a pointer to a
subroutine.  It is called immediately prior to writing to the socket
connection. It is called by \fBMail::IMAPClient\fR with two arguments:
a reference to the \fBMail::IMAPClient\fR object and the \s-1ASCII\s0 text
string to be written.  It should return another string that will be
the actual string sent to the \s-1IMAP\s0 server.  The idea here is that your
\&\fIPrewritemethod\fR will do whatever encryption is necessary and then
return the result to the caller so it in turn can be sent to the server.
.IP "Ignoresizeerrors" 4
.IX Item "Ignoresizeerrors"
Certain (caching) servers, like Exchange 2007, often report the wrong
message size.  Instead of chopping the message into a size that it
fits the specified size, the reported size will be simply ignored
when this parameter is set to \f(CW1\fR.
.IP "Supportedflags" 4
.IX Item "Supportedflags"
Especially when \f(CW\*(C`migrate()\*(C'\fR is used, the receiving peer may need to
be configured explicitly with the list of supported flags; that may
be different from the source \s-1IMAP\s0 server.
.Sp
The names are to be specified as an \s-1ARRAY\s0.  Black-slashes and casing
will be ignored.
.Sp
You may also specify a \s-1CODE\s0 reference, which will be called for each of
the flags seperately.  In this case, the flags are not (yet) normalized.
The returned lists of the \s-1CODE\s0 calls are shape the resulting flag list.
.Sh "Errors"
.IX Subsection "Errors"
If you attempt an operation that results in an error, then you can
retrieve the text of the error message by using the LastError
method. However, since the LastError method is an object method (and
not a class method) you will only be able to use this method if you've
successfully created your object. Errors in the new method can
prevent your object from ever being created. Additionally, if you
supply the \fIServer\fR, \fIUser\fR, and \fIPassword\fR parameters to new, it
will attempt to call \fBconnect\fR and \fBlogin\fR, either of which could
fail and cause your new method call to return \f(CW\*(C`undef\*(C'\fR (in which case
your object will have been created but its reference will have been
discarded before ever having been returned to you).
.PP
If this happens to you, you can always check \f(CW$@\fR. \fBMail::IMAPClient\fR
will populate that variable with something useful if either of the
new, connect, or login methods fail. In fact, as of version 2,
the \f(CW$@\fR variable will always contain error info from the last error,
so you can print that instead of calling LastError if you wish. 
.PP
If you run your script with warnings turned on (which I'm sure you'll
do at some point because it's such a good idea) then any error message
that gets placed into the LastError slot (and/or in \f(CW$@\fR) will
automatically generate a warning. 
.Sh "Transactions"
.IX Subsection "Transactions"
\&\s-1RFC2060\s0 requires that each line in an \s-1IMAP\s0 conversation be prefixed
with a tag. A typical conversation consists of the client issuing a
tag-prefixed command string, and the server replying with one of more
lines of output. Those lines of output will include a command
completion status code prefixed by the same tag as the original command
string.
.PP
The \fBIMAPClient\fR module uses a simple counter to ensure that each
client command is issued with a unique tag value. This tag value is
referred to by the \fBIMAPClient\fR module as the transaction number. A
history is maintained by the \fBIMAPClient\fR object documenting each
transaction. The Transaction method returns the number of the last
transaction, and can be used to retrieve lines of text from the
object's history. 
.PP
The Clear parameter is used to control the size of the session
history so that long-running sessions do not eat up unreasonable
amounts of memory. See the discussion of Clear under \*(L"Parameters\*(R"
for more information.
.PP
The Report transaction returns the history of the entire \s-1IMAP\s0
session since the initial connection or for the last \fIClear\fR
transactions. This provides a record of the entire conversation,
including client command strings and server responses, and is a
wonderful debugging tool as well as a useful source of raw data for
custom parsing.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
There are a couple of methods that can be invoked as class methods.
Generally they can be invoked as an object method as well, as a
convenience to the programmer. (That is, as a convenience to the
programmer who wrote this module, as well as the programmers using it.
It's easier \fInot\fR to enforce a class method's classiness.) Note that
if the new method is called as an object method, the object returned
is identical to what have would been returned if new had been called
as a class method. It doesn't give you a copy of the original object or
anything like that.
.Sh "new"
.IX Subsection "new"
Example:
.PP
.Vb 1
\&        Mail::IMAPClient->new(%args) or die "Could not new: $@\en";
.Ve
.PP
The new method creates a new instance of an \fBIMAPClient\fR object. If
the \fIServer\fR parameter is passed as an argument to \fBnew\fR, then \fBnew\fR
will implicitly call the connect method, placing the new object in
the \fIConnected\fR state. If \fIUser\fR and \fIPassword\fR values are also
provided, then connect will in turn call login, and the resulting
object will be returned from \fBnew\fR in the \fIAuthenticated\fR state.
.PP
If the \fIServer\fR parameter is not supplied then the \fBIMAPClient\fR
object is created in the \fIUnconnected\fR state.
.PP
If the \fBnew\fR method is passed arguments then those arguments will be
treated as a list of key=>value pairs. The key should be one of the
parameters as documented under \*(L"Parameters\*(R", below. 
.PP
Here are some examples:
.PP
.Vb 1
\&        use Mail::IMAPClient;
.Ve
.PP
.Vb 12
\&        # returns an unconnected Mail::IMAPClient object:
\&        my $imap = Mail::IMAPClient->new;       
\&        #       ...                             
\&        # intervening code using the 1st object, then:
\&        # (returns a new, authenticated Mail::IMAPClient object)
\&        $imap = Mail::IMAPClient->new(  
\&                        Server => $host,
\&                        User    => $id,
\&                        Password=> $pass,
\&                        Clear   => 5,   # Unnecessary since '5' is the default
\&        #               ...             # Other key=>value pairs go here
\&        )       or die "Cannot connect to $host as $id: $@";
.Ve
.PP
See also \*(L"Parameters\*(R", below, and \*(L"connect\*(R" and \*(L"login\*(R" for
information on how to manually connect and login after \fBnew\fR.
.Sh "Authenticated"
.IX Subsection "Authenticated"
Example:
.PP
.Vb 3
\&        $Authenticated = $imap->Authenticated();
\&        # or:
\&        $imap->Authenticated($new_value);  # But you'll probably never need to do this
.Ve
.PP
returns a value equal to the numerical value associated with an object
in the \fBAuthenticated\fR state. This value is normally maintained by the
\&\fBMail::IMAPClient\fR module, so you typically will only query it and 
won't need to set it.
.PP
\&\fB\s-1NOTE:\s0\fR For a more programmer-friendly idiom, see the IsUnconnected,
IsConnected, IsAuthenticated, and IsSelected object methods. You 
will usually want to use those methods instead of one of the above.
.Sh "Connected"
.IX Subsection "Connected"
Example:
.PP
.Vb 3
\&        $Connected = $imap->Connected();
\&        # or:
\&        $imap->Connected($new_value); # But you'll probably never need to do this
.Ve
.PP
returns a value equal to the numerical value associated with an object
in the \fBConnected\fR state.  This value is normally maintained by the
\&\fBMail::IMAPClient\fR module, so you typically will only query it and 
won't need to set it.
.PP
\&\fB\s-1NOTE:\s0\fR For a more programmer-friendly idiom, see the IsUnconnected,
IsConnected, IsAuthenticated, and IsSelected object methods. You 
will usually want to use those methods instead of one of the above.
.Sh "Quote"
.IX Subsection "Quote"
Example:
.PP
.Vb 1
\&        $imap->search(HEADER => 'Message-id' => $imap->Quote($msg_id));
.Ve
.PP
The \fBQuote\fR method accepts a value as an argument.  It returns its 
argument as a correctly quoted string or a literal string.
.PP
Note that you should not use this on folder names, since methods that accept
folder names as an argument will quote the folder name arguments appropriately
for you. (Exceptions to this rule are methods that come with \s-1IMAP\s0 extensions 
that are not explicitly supported by \fBMail::IMAPClient\fR.)
.PP
If you are getting unexpected results when running methods with values that 
have (or might have) embedded spaces, double quotes, braces, or parentheses, 
then you may wish to call \fBQuote\fR to quote these values. You should \fBnot\fR 
use this method with foldernames or with arguments that are wrapped in quotes 
or parens if those quotes or parens are there because the \s-1RFC2060\s0 spec requires 
them. So, for example, if \s-1RFC\s0 requires an argument in this format:
.PP
.Vb 1
\&        ( argument )
.Ve
.PP
and your argument is (or might be) \*(L"pennies (from heaven)\*(R", then you could just
use: 
.PP
.Vb 1
\&        $argument = "(" . $imap->Quote($argument) . ")"
.Ve
.PP
and be done with it.
.PP
Of course, the fact that sometimes these characters are sometimes required 
delimiters is precisely the reason you must quote them when they are \fInot\fR 
delimiting. For example:
.PP
.Vb 3
\&        $imap->Search('SUBJECT',"(no subject)");
\&        # WRONG! Sends this to imap server: 
\&        #<TAG> Search SUBJECT (no subject)\er\en
.Ve
.PP
.Vb 3
\&        $imap->Search('SUBJECT',$imap->Quote("(no subject)"));
\&        # Correct! Sends this to imap server: 
\&        #<TAG> Search SUBJECT "(no subject)"\er\en
.Ve
.PP
On the other hand:
.PP
.Vb 3
\&        $imap->store('+FLAGS',$imap->Quote("(\eDeleted)"));
\&        # WRONG! Sends this to imap server: 
\&        #<TAG> [UID] STORE +FLAGS "(\eDeleted)"\er\en
.Ve
.PP
.Vb 3
\&        $imap->store($imap->Quota('+FLAGS'),"(\eDeleted)");
\&        # CORRECT! Sends this to imap server: 
\&        #<TAG> [UID] STORE +FLAGS (\eDeleted)\er\en
.Ve
.PP
In the above, I had to abandon the many methods available to 
\&\fBMail::IMAPClient\fR programmers (such as delete_message and all-lowercase 
search) for the sake of coming up with an example. However, there are 
times when unexpected values in certain places will force you to \fBQuote\fR. 
An example is \s-1RFC822\s0 Message\-id's, which \fIusually\fR don't contain quotes or 
parens. So you don't worry about it, until suddenly searches for certain 
message\-id's fail for no apparent reason. (A failed search is not simply a 
search that returns no hits; it's a search that flat out didn't happen.) 
This normally happens to me at about 5:00 pm on the one day when I was hoping 
to leave on time. (By the way, my experience is that any character that can 
possibly find its way into a Message-Id eventually will, so when dealing
with these values take proactive, defensive measures from the very start.
In fact, as I was typing the above, a buddy of mine came in to ask advice about
a logfile parsing routine he was writing in which the fields were delimited
by colons. One of the fields was a Message Id, and, you guessed it, some of the
message id's in the log had (unescaped!) colons embedded in them and were 
screwing up his \f(CW\*(C`split()\*(C'\fR.  So there you have it, it's not just me. This is 
everyone's problem.)
.Sh "Range"
.IX Subsection "Range"
Example:
.PP
.Vb 5
\&        my %parsed = $imap->parse_headers(
\&                                $imap->Range($imap->messages),
\&                                "Date",
\&                                "Subject"
\&        );
.Ve
.PP
The \fBRange\fR method will condense a list of message sequence numbers or
message \s-1UID\s0's into the most compact format supported by \s-1RFC2060\s0. It accepts
one or more arguments, each of which can be:
.IP "a) a message number," 8
.IX Item "a) a message number,"
.PD 0
.IP "b) a comma-separated list of message numbers," 8
.IX Item "b) a comma-separated list of message numbers,"
.ie n .IP "c) a colon-separated range of message numbers (i.e. ""$begin:$end"")" 8
.el .IP "c) a colon-separated range of message numbers (i.e. ``$begin:$end'')" 8
.IX Item "c) a colon-separated range of message numbers (i.e. $begin:$end)"
.IP "d) a combination of messages and message ranges, separated by commas (i.e. 1,3,5:8,10), or" 8
.IX Item "d) a combination of messages and message ranges, separated by commas (i.e. 1,3,5:8,10), or"
.IP "e) a reference to an array whose elements are like \fIa)\fR through \fId)\fR." 8
.IX Item "e) a reference to an array whose elements are like a) through d)."
.PD
.PP
The \fBRange\fR method returns a reference to a \fBMail::IMAPClient::MessageSet\fR
object. The object has all kinds of magic properties, one of which being that
if you treat it as if it were just a string it will act like it's just a 
string. This means you can ignore its objectivity and just treat it like a
string whose value is your message set expressed in compact format.
.PP
You may want to use this method if you find that fetch operations on large
message sets seem to take a really long time, or if your server rejects
these requests with the claim that the input line is too long. You may also
want to use this if you need to add or remove messages to your message set
and want an easy way to manage this. 
.PP
For more information on the capabilities of the returned object reference,
see Mail::IMAPClient::MessageSet.
.Sh "Rfc2060_date"
.IX Subsection "Rfc2060_date"
Example:
.PP
.Vb 3
\&        $Rfc2060_date = $imap->Rfc2060_date($seconds);
\&        # or:
\&        $Rfc2060_date = Mail::IMAPClient->Rfc2060_date($seconds);
.Ve
.PP
The \fBRfc2060_date\fR method accepts one input argument, a number of
seconds since the epoch date. It returns an \s-1RFC2060\s0 compliant date
string for that date (as required in date-related arguments to \s-1SEARCH\s0,
such as \*(L"since\*(R", \*(L"before\*(R", etc.). 
.Sh "Rfc2060_datetime"
.IX Subsection "Rfc2060_datetime"
Example:
.PP
.Vb 3
\&        $date = $imap->Rfc2060_datetime($seconds);
\&        # or:
\&        $date = Mail::IMAPClient->Rfc2060_datetime($seconds);
.Ve
.PP
The \fBRfc2060_datetime\fR method accepts one or two arguments: a obligatory
timestamp and an optional zone.  The zone shall be formatted as
\&\f(CW\*(C`[+\-]\ed{4}\*(C'\fR, and defaults to \f(CW+0000\fR.  The timestamp follows the
definition of the output of the platforms specific \f(CW\*(C`time\*(C'\fR, usually in
seconds since Jan 1st 1970.  However, you have to correct the number
yourself for the zone.
.Sh "Rfc822_date"
.IX Subsection "Rfc822_date"
Example:
.PP
.Vb 3
\&        $Rfc822_date = $imap->Rfc822_date($seconds);
\&        # or:
\&        $Rfc822_date = Mail::IMAPClient->Rfc822_date($seconds);
.Ve
.PP
The \fBRfc822_date\fR method accepts one input argument, a number of
seconds since the epoch date. It returns an \s-1RFC822\s0 compliant date
string for that date (without the 'Date:' prefix). Useful for putting
dates in message strings before calling append, search, etcetera.
.Sh "Selected"
.IX Subsection "Selected"
Example:
.PP
.Vb 3
\&        $Selected = $imap->Selected();
\&        # or:
\&        $imap->Selected($new_value); # But you'll probably never need to do this
.Ve
.PP
returns a value equal to the numerical value associated with an object
in the \fBSelected\fR state.  This value is normally maintained by the
\&\fBMail::IMAPClient\fR module, so you typically will only query it and 
won't need to set it.
.PP
\&\fB\s-1NOTE:\s0\fR For a more programmer-friendly idiom, see the IsUnconnected,
IsConnected, IsAuthenticated, and IsSelected object methods. You 
will usually want to use those methods instead of one of the above.
.Sh "Strip_cr"
.IX Subsection "Strip_cr"
Example:
.PP
.Vb 3
\&        $Strip_cr = $imap->Strip_cr();
\&        # or:
\&        $imap->Strip_cr($new_value);
.Ve
.PP
The \fBStrip_cr\fR method strips carriage returns from \s-1IMAP\s0 client command
output. Although \s-1RFC2060\s0 specifies that lines in an \s-1IMAP\s0 conversation
end with <\s-1CR\s0><\s-1LF\s0>, it is often cumbersome to have the carriage returns
in the returned data. This method accepts one or more lines of text as
arguments, and returns those lines with all <\s-1CR\s0><\s-1LF\s0> sequences changed
to <\s-1LF\s0>. Any input argument with no carriage returns is returned
unchanged. If the first argument (not counting the class name or object
reference) is an array reference, then members of that array are
processed as above and subsequent arguments are ignored. If the method
is called in scalar context then an array reference is returned instead
of an array of results.
.PP
Taken together, these last two lines mean that you can do something
like:
.PP
.Vb 5
\&        my @list = $imap->some_imap_method ;
\&        @list = $imap->Strip_cr(@list) ; 
\&        # or: 
\&        my $list = [ $imap->some_imap_method ] ; # returns an array ref
\&        $list = $imap->Strip_cr($list);
.Ve
.PP
\&\fB\s-1NOTE:\s0 Strip_cr\fR does not remove new line characters.
.Sh "Unconnected"
.IX Subsection "Unconnected"
Example:
.PP
.Vb 3
\&        $Unconnected = $imap->Unconnected();
\&        # or:
\&        $imap->Unconnected($new_value);
.Ve
.PP
returns a value equal to the numerical value associated with an object
in the \fBUnconnected\fR state.  This value is normally maintained by the
\&\fBMail::IMAPClient\fR module, so you typically will only query it and 
won't need to set it.
.PP
\&\fB\s-1NOTE:\s0\fR For a more programmer-friendly idiom, see the IsUnconnected,
IsConnected, IsAuthenticated, and IsSelected object methods. You 
will usually want to use those methods instead of one of the above.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
Object methods must be invoked against objects created via the new
method. They cannot be invoked as class methods, which is why they are
called \*(L"object methods\*(R" and not \*(L"class methods\*(R". 
.PP
There are basically two types of object methods\*(--mailbox methods, which 
participate in the \s-1IMAP\s0 session's conversation (i.e. they issue \s-1IMAP\s0 
client commands) and object control methods, which do not result in 
\&\s-1IMAP\s0 commands but which may affect later commands or provide details
of previous ones. This latter group can be further broken down into
two types, Parameter accessor methods, which affect the behavior of 
future mailbox methods, and Status methods, which report on the affects
of previous mailbox methods.
.PP
Methods that do not result in new \s-1IMAP\s0 client commands being issued 
(such as the Transaction, Status, and History methods) all 
begin with an uppercase letter, to distinguish them from methods that 
do correspond to \s-1IMAP\s0 client commands. Class methods and eponymous 
parameter methods likewise begin with an uppercase letter because 
they also do not correspond to an \s-1IMAP\s0 client command.
.PP
As a general rule, mailbox control methods return \f(CW\*(C`undef\*(C'\fR on failure 
and something besides \f(CW\*(C`undef\*(C'\fR when they succeed. This rule is modified 
in the case of methods that return search results. When called in a list 
context, searches that do not find matching results return an empty list. 
When called in a scalar context, searches with no hits return 'undef' 
instead of an array reference. If you want to know why you received no hits,
you should check \f(CW$@\fR, which will be empty if the search was successful
but had no matching results but populated with an error message if the 
search encountered a problem (such as invalid parameters).
.PP
A number of \s-1IMAP\s0 commands do not have corresponding \fBMail::IMAPClient\fR
methods.  Please contribute them.  In pre\-2.99 releases of this module,
they were automatically created, but that was very error-prone and stalled
the progress of this module.
.SH "Mailbox Control Methods"
.IX Header "Mailbox Control Methods"
.Sh "append"
.IX Subsection "append"
Example:
.PP
.Vb 2
\&        my $uid = $imap->append($folder,$msg_text) 
\&                or die "Could not append: $@\en";
.Ve
.PP
The \fBappend\fR method adds a message to the specified folder. It takes
two arguments, the name of the folder to append the message to, and the
text of the message (including headers). Additional arguments are added
to the message text, separated with <\s-1CR\s0><\s-1LF\s0>.
.PP
The \fBappend\fR method returns the \s-1UID\s0 of the new message (a true value)
if successful, or \f(CW\*(C`undef\*(C'\fR if not, if the \s-1IMAP\s0 server has the \s-1UIDPLUS\s0
capability. If it doesn't then you just get true on success and undef
on failure.
.PP
Note that many servers will get really ticked off if you try to append
a message that contains \*(L"bare newlines\*(R", which is the titillating term
given to newlines that are not preceded by a carrage return. To protect
against this, \fBappend\fR will insert a carrage return before any newline
that is \*(L"bare\*(R". If you don't like this behavior then you can avoid it
by not passing naked newlines to \fBappend\fR.
.PP
Note that \fBappend\fR does not allow you to specify the internal date or
initial flags of an appended message. If you need this capability then
use append_string, below.
.Sh "append_file"
.IX Subsection "append_file"
Example:
.PP
.Vb 5
\&        my $new_msg_uid = $imap->append_file(
\&                $folder,
\&                $filename,
\&                [$input_record_separator, flags, date] # optional
\&        )       or die "Could not append_file: $@\en";
.Ve
.PP
The \fBappend_file\fR method adds a message to the specified folder. It
takes two arguments, the name of the folder to append the message to,
and the file name of an RFC822\-formatted message.
.PP
An optional third argument is the value to use for
\&\f(CW\*(C`input_record_separator\*(C'\fR. The default is to use "\*(L" for the first read
(to get the headers) and \*(R"\en" for the rest. Any valid value for \f(CW$/\fR
is acceptable, even the funky stuff, like \f(CW\*(C`\e1024\*(C'\fR. (See perlvar 
for more information on \f(CW$/\fR). (The brackets in the example indicate
that this argument is optional; they do not mean that the argument 
should be an array reference.)
.PP
The \fBappend_file\fR method returns the \s-1UID\s0 of the new message (a true
value) if successful, or \f(CW\*(C`undef\*(C'\fR if not, if the \s-1IMAP\s0 server has the
\&\s-1UIDPLUS\s0 capability. If it doesn't then you just get true on success and
undef on failure. If you supply a filename that doesn't exist then you
get an automatic \f(CW\*(C`undef\*(C'\fR. The LastError method will remind you of this
if you forget that your file doesn't exist but somehow manage to
remember to check LastError.
.PP
In case you're wondering, \fBappend_file\fR is provided mostly as a way to
allow large messages to be appended without having to have the whole
file in memory. It uses the \f(CW\*(C`\-s\*(C'\fR operator to obtain the size of the
file and then reads and sends the contents line by line (or not,
depending on whether you supplied that optional third argument).
.Sh "append_string"
.IX Subsection "append_string"
Example:
.PP
.Vb 3
\&   # brackets indicate optional arguments (not array refs):
\&   my $uid = $imap->append_string( $folder, $text [,$flags [,$date ] ])         
\&       or die "Could not append_string: $@\en";
.Ve
.PP
The \fBappend_string\fR method adds a message to the specified folder. It
requires two arguments, the name of the folder to append the message
to, and the text of the message (including headers). The message text
must be included in a single string (unlike append, above).
.PP
You can optionally specify a third and fourth argument to
\&\fBappend_string\fR. The third argument, if supplied, is the list of flags
to set for the appended message. The list must be specified as a
space-separated list of flags, including any backslashes that may be
necessary. The enclosing parentheses that are required by \s-1RFC2060\s0 are
optional for \fBappend_string\fR. The fourth argument, if specified, is
the date to set as the internal date. It should be in the format
described for \fIdate_time\fR fields in \s-1RFC2060\s0, i.e. \*(L"dd\-Mon\-yyyy
hh:mm:ss +0000\*(R".
.PP
If you want to specify a date/time but you don't want any flags then
specify \fIundef\fR as the third argument.
.PP
The \fBappend_string\fR method returns the \s-1UID\s0 of the new message (a true
value) if successful, or \f(CW\*(C`undef\*(C'\fR if not, if the \s-1IMAP\s0 server has the
\&\s-1UIDPLUS\s0 capability. If it doesn't then you just get true on success and
undef on failure.
.PP
Note that many servers will get really ticked off if you try to append
a message that contains \*(L"bare newlines\*(R", which is the titillating term
given to newlines that are not preceded by a carrage return. To protect
against this, \fBappend_string\fR will insert a carrage return before any
newline that is \*(L"bare\*(R". If you don't like this behavior then you can
avoid it by not passing naked newlines to \fBappend_string\fR.
.Sh "authenticate"
.IX Subsection "authenticate"
Example:
.PP
.Vb 2
\&        $imap->authenticate($authentication_mechanism, $coderef) 
\&                or die "Could not authenticate: $@\en";
.Ve
.PP
The \fBauthenticate\fR method accepts two arguments, an authentication
type to be used (ie \s-1CRAM\-MD5\s0) and a code or subroutine reference to
execute to obtain a response. The \fBauthenticate\fR method assumes that 
the authentication type specified in the first argument follows a
challenge-response flow. The \fBauthenticate\fR method issues the \s-1IMAP\s0
Client \s-1AUTHENTICATE\s0 command and receives a challenge from the server.
That challenge (minus any tag prefix or enclosing '+' characters but
still in the original base64 encoding) is passed as the only argument
to the code or subroutine referenced in the second argument. The return
value from the 2nd argument's code is written to the server as is,
except that a <\s-1CR\s0><\s-1NL\s0> sequence is appended if neccessary.
.PP
If one or both of the arguments are not specified in the call to
\&\fBauthenticate\fR but their corresponding parameters have been set
(\fIAuthmechanism\fR and \fIAuthcallback\fR, respectively) then the parameter
values are used. Arguments provided to the method call however will
override parameter settings.
.PP
If you do not specify a second argument and you have not set the 
\&\fIAuthcallback\fR parameter, then the first argument must be
one of the authentication mechanisms for which \fBMail::IMAPClient\fR
has built in support.
.PP
If you are interested in doing \s-1NTLM\s0 authentication then please see Mark
Bush's Authen::NTLM, which can work with \fBMail::IMAPClient\fR to
provide \s-1NTLM\s0 authentication.
.PP
See also the login method, which is the simplest form of
authentication defined by \s-1RFC2060\s0.
.Sh "before"
.IX Subsection "before"
Example:
.PP
.Vb 2
\&        my @msgs = $imap->before($Rfc2060_date) 
\&                or warn "No messages found before $Rfc2060_date.\en";
.Ve
.PP
The \fBbefore\fR method works just like the \*(L"since\*(R" method, below,
except it returns a list of messages whose internal system dates are
before the date supplied as the argument to the \fBbefore\fR method.
.Sh "body_string"
.IX Subsection "body_string"
Example:
.PP
.Vb 2
\&        my $string = $imap->body_string($msgId) 
\&                or die "Could not body_string: $@\en";
.Ve
.PP
The \fBbody_string\fR method accepts a message sequence number (or a
message \s-1UID\s0, if the Uid parameter is set to true) as an argument and
returns the message body as a string. The returned value contains the
entire message in one scalar variable, without the message headers.
.Sh "bodypart_string"
.IX Subsection "bodypart_string"
Example:
.PP
.Vb 3
\&        my $string=$imap->bodypart_string(      $msgid, $part_number , 
\&                                                $length ,$offset  
\&        )       or die "Could not get bodypart string: $@\en";
.Ve
.PP
The \fBbodypart_string\fR method accepts a message sequence number (or a
message \s-1UID\s0, if the Uid parameter is set to true) and a body part as
arguments and returns the message part as a string. The returned value
contains the entire message part (or, optionally, a portion of the part) 
in one scalar variable.
.PP
If an optional third argument is provided, that argument is the number
of bytes to fetch. (The default is the whole message part.) If an
optional fourth argument is provided then that fourth argument is the
offset into the part at which the fetch should begin. The default is
offset zero, or the beginning of the message part.
.PP
If you specify an offset without specifying a length then the offset
will be ignored and the entire part will be returned.
.PP
\&\fBbodypart_string\fR will return \f(CW\*(C`undef\*(C'\fR if it encounters an error.
.Sh "capability"
.IX Subsection "capability"
Example:
.PP
.Vb 2
\&        my @features = $imap->capability
\&                or die "Could not determine capability: $@\en";
.Ve
.PP
The \fBcapability\fR method returns an array of capabilities as returned
by the \s-1CAPABILITY\s0 \s-1IMAP\s0 Client command, or a reference to an array of
capabilities if called in scalar context. If the \s-1CAPABILITY\s0 \s-1IMAP\s0 Client
command fails for any reason then the \fBcapability\fR method will return
\&\f(CW\*(C`undef\*(C'\fR.
.Sh "close"
.IX Subsection "close"
Example:
.PP
.Vb 1
\&        $imap->close or die "Could not close: $@\en";
.Ve
.PP
The \fBclose\fR method is implemented via the default method and is used
to close the currently selected folder via the \s-1CLOSE\s0 \s-1IMAP\s0 client
command. According to \s-1RFC2060\s0, the \s-1CLOSE\s0 command performs an implicit
\&\s-1EXPUNGE\s0, which means that any messages that you've flagged as
\&\fI\eDeleted\fR (say, with the delete_message method) will now be
deleted. If you haven't deleted any messages then \fBclose\fR can be
thought of as an \*(L"unselect\*(R".
.PP
Note again that this closes the currently selected folder, not the 
\&\s-1IMAP\s0 session.
.PP
See also delete_message, expunge, and your tattered copy of
\&\s-1RFC2060\s0.
.Sh "connect"
.IX Subsection "connect"
Example:
.PP
.Vb 1
\&        $imap->connect or die "Could not connect: $@\en";
.Ve
.PP
The \fBconnect\fR method connects an imap object to the server. It returns
\&\f(CW\*(C`undef\*(C'\fR if it fails to connect for any reason. If values are available
for the \fIUser\fR and \fIPassword\fR parameters at the time that \fBconnect\fR
is invoked, then \fBconnect\fR will call the login method after
connecting and return the result of the login method to \fBconnect\fR's
caller. If either or both of the \fIUser\fR and \fIPassword\fR parameters are
unavailable but the connection to the server succeeds then \fBconnect\fR
returns a pointer to the \fBIMAPClient\fR object.
.PP
The \fIServer\fR parameter must be set (either during new method
invocation or via the Server object method) before invoking \fBconnect\fR.
When the parameter is an absolute file path, an \s-1UNIX\s0 socket will get
opened.  If the Server parameter is supplied to the new method
then \fBconnect\fR is implicitly called during object construction.
.PP
The \fBconnect\fR method sets the state of the object to \f(CW\*(C`connected\*(C'\fR if
it successfully connects to the server. It returns \f(CW\*(C`undef\*(C'\fR on failure.
.Sh "copy"
.IX Subsection "copy"
Example:
.PP
.Vb 3
\&        # Here brackets indicate optional arguments:
\&        my $uidList = $imap->copy($folder, $msg_1 [ , ... , $msg_n ]) 
\&        or die "Could not copy: $@\en";
.Ve
.PP
Or:
.PP
.Vb 3
\&        # Now brackets indicate an array ref!
\&        my $uidList = $imap->copy($folder, [ $msg_1, ... , $msg_n ]) 
\&        or die "Could not copy: $@\en";
.Ve
.PP
The \fBcopy\fR method requires a folder name as the first argument, and a
list of one or more messages sequence numbers (or messages \s-1UID\s0's, if
the \fI\s-1UID\s0\fR parameter is set to a true value). The message sequence
numbers or \s-1UID\s0's should refer to messages in the currenly selected
folder. Those messages will be copied into the folder named in the
first argument.
.PP
The \fBcopy\fR method returns \f(CW\*(C`undef\*(C'\fR on failure and a true value if
successful. If the server to which the current Mail::IMAPClient object
is connected supports the \s-1UIDPLUS\s0 capability then the true value
returned by \fBcopy\fR will be a comma separated list of \s-1UID\s0's, which are
the \s-1UID\s0's of the newly copied messages in the target folder. 
.Sh "create"
.IX Subsection "create"
Example:
.PP
.Vb 2
\&        $imap->create($new_folder) 
\&                or die "Could not create $new_folder: $@\en";
.Ve
.PP
The \fBcreate\fR method accepts one argument, the name of a folder (or
what \s-1RFC2060\s0 calls a \*(L"mailbox\*(R") to create. If you specifiy additional
arguments to the \fBcreate\fR method and your server allows additional
arguments to the \s-1CREATE\s0 \s-1IMAP\s0 client command then the extra argument(s)
will be passed to your server. 
.PP
If you specifiy additional arguments to the \fBcreate\fR method and your
server does not allow additional arguments to the \s-1CREATE\s0 \s-1IMAP\s0 client
command then the extra argument(s) will still be passed to your server
and the create will fail, so don't do that.
.PP
\&\fBcreate\fR returns a true value on success and \f(CW\*(C`undef\*(C'\fR on failure, as
you've probably guessed.
.Sh "date"
.IX Subsection "date"
Example:
.PP
.Vb 1
\&        my $date = $imap->date($msg);
.Ve
.PP
The \fBdate\fR method accepts one argument, a message sequence number (or a
message \s-1UID\s0 if the \fIUid\fR parameter is set to a true value). It returns 
the date of message as specified in the message's \s-1RFC822\s0 \*(L"Date: \*(R" header,
without the \*(L"Date: \*(R" prefix.
.PP
The \fBdate\fR method is a short-cut for:
.PP
.Vb 1
\&        my $date = $imap->get_header($msg,"Date");
.Ve
.Sh "delete"
.IX Subsection "delete"
Example:
.PP
.Vb 1
\&        $imap->delete($folder) or die "Could not delete $folder: $@\en";
.Ve
.PP
The \fBdelete\fR method accepts a single argument, the name of a folder to
delete. It returns a true value on success and \f(CW\*(C`undef\*(C'\fR on failure.
.Sh "delete_message"
.IX Subsection "delete_message"
Example:
.PP
.Vb 3
\&        my @msgs = $imap->seen;
\&        scalar(@msgs) and $imap->delete_message(\e@msgs) 
\&                or die "Could not delete_message: $@\en";
.Ve
.PP
The above could also be rewritten like this:
.PP
.Vb 2
\&        # scalar context returns array ref
\&        my $msgs = scalar($imap->seen);
.Ve
.PP
.Vb 2
\&        scalar(@$msgs) and $imap->delete_message($msgs) 
\&                or die "Could not delete_message: $@\en";
.Ve
.PP
Or, as a one\-liner:
.PP
.Vb 4
\&        $imap->delete_message( scalar($imap->seen) )
\&                or warn "Could not delete_message: $@\en";
\&        # just give warning in case failure is 
\&        # due to having no 'seen' msgs in the 1st place!
.Ve
.PP
The \fBdelete_message\fR method accepts a list of arguments. If the Uid
parameter is not set to a true value, then each item in the list should
be either: 
.IP "> a message sequence number," 4
.IX Item "> a message sequence number,"
.PD 0
.IP "> a comma-separated list of message sequence numbers," 4
.IX Item "> a comma-separated list of message sequence numbers,"
.IP "> a reference to an array of message sequence numbers, or" 4
.IX Item "> a reference to an array of message sequence numbers, or"
.PD
.PP
If the Uid parameter is set to a true value, then each item in the
list should be either: 
.IP "> a message \s-1UID\s0," 4
.IX Item "> a message UID,"
.PD 0
.IP "> a comma-separated list of \s-1UID\s0's, or" 4
.IX Item "> a comma-separated list of UID's, or"
.IP "> a reference to an array of message \s-1UID\s0's." 4
.IX Item "> a reference to an array of message UID's."
.PD
.PP
The messages identified by the sequence numbers or \s-1UID\s0's will be
deleted. If successful, \fBdelete_message\fR returns the number 
of messages it was told to delete. However, since the delete is 
done by issuing the \fI+FLAGS.SILENT\fR option of the \s-1STORE\s0 \s-1IMAP\s0 
client command, there is no guarantee that the delete was successful 
for every message. In this manner the \fBdelete_message\fR method sacrifices 
accuracy for speed. Generally, though, if a single message in a list 
of messages fails to be deleted it's because it was already deleted,
which is what you wanted anyway so why worry about it? If there is
a more severe error, i.e. the server replies \*(L"\s-1NO\s0\*(R", \*(L"\s-1BAD\s0\*(R", or, 
banish the thought, \*(L"\s-1BYE\s0\*(R", then \fBdelete_message\fR will return \f(CW\*(C`undef\*(C'\fR.
.PP
If you must have guaranteed results then use the \s-1IMAP\s0 \s-1STORE\s0 client
command (via the default method) and use the +FLAGS (\eDeleted) option,
and then parse your results manually.
.PP
Eg: 
.PP
.Vb 3
\&        $imap->store($msg_id,'+FLAGS (\eDeleted)');
\&        my @results = $imap->History($imap->Transaction);
\&        ...                     # code to parse output goes here
.Ve
.PP
(Frankly I see no reason to bother with any of that; if a message doesn't get 
deleted it's almost always because it's already not there, which is what you 
want anyway. But 'your milage may vary' and all that.)
.PP
The \fBIMAPClient\fR object must be in \f(CW\*(C`Selected\*(C'\fR status to use the
\&\fBdelete_message\fR method. 
.PP
\&\fB\s-1NOTE:\s0\fR All the messages identified in the input argument(s) must be
in the currently selected folder. Failure to comply with this
requirement will almost certainly result in the wrong message(s) being
deleted. This would be a crying shame. 
.PP
\&\fB\s-1NOTE\s0 \s-1SOME\s0 \s-1MORE:\s0\fR In the grand tradition of the \s-1IMAP\s0 protocol,
deleting a message doesn't actually delete the message. Really. If you
want to make sure the message has been deleted, you need to expunge the
folder (via the expunge method, which is implemented via the default
method). Or at least close it. This is generally considered a
feature, since after deleting a message, you can change your mind and
undelete it at any time before your expunge or close.
.PP
\&\fISee also:\fR The delete method, to delete a folder, the expunge
method, to expunge a folder, the restore_message method to undelete
a message, and the close method (implemented here via the default
method) to close a folder. Oh, and don't forget about \s-1RFC2060\s0. 
.Sh "deny_seeing"
.IX Subsection "deny_seeing"
Example:
.PP
.Vb 4
\&        # Reset all read msgs to unread 
\&        # (produces error if there are no seen msgs):
\&        $imap->deny_seeing( scalar($imap->seen) ) 
\&                or die "Could not deny_seeing: $@\en" ;
.Ve
.PP
The \fBdeny_seeing\fR method accepts a list of one or more message
sequence numbers, or a single reference to an array of one or more
message sequence numbers, as its argument(s). It then unsets the
\&\*(L"\eSeen\*(R" flag for those messages (so that you can \*(L"deny\*(R" that you ever 
saw them). Of course, if the Uid parameter is set to a true value 
then those message sequence numbers should be unique message id's. 
.PP
Note that specifying \f(CW\*(C`$imap\->deny_seeing(@msgs)\*(C'\fR is just a
shortcut for specifying \f(CW\*(C`$imap\->unset_flag("Seen",@msgs)\*(C'\fR. 
.Sh "disconnect"
.IX Subsection "disconnect"
Example:
.PP
.Vb 1
\&        $imap->disconnect or warn "Could not disconnect: $@\en";
.Ve
.PP
Disconnects the \fBIMAPClient\fR object from the server. Functionally
equivalent to the logout method. (In fact it's actually a synonym
for logout.)
.Sh "done"
.IX Subsection "done"
Example:
.PP
.Vb 3
\&        my $idle = $imap->idle or warn "Couldn't idle: $@\en";
\&        &goDoOtherThings;
\&        $imap->done($idle) or warn "Error from done: $@\en";
.Ve
.PP
The \fBdone\fR method tells the \s-1IMAP\s0 server that the connection is finished
idling. See idle for more information. It accepts one argument, 
which is the transaction number you received from the previous call
to idle.
.PP
If you pass the wrong transaction number to \fBdone\fR then your perl program
will probably hang. If you don't pass any transaction number to \fBdone\fR
then it will try to guess, and if it guesses wrong it will hang.
.PP
If you call done without previously having called idle then your 
server will mysteriously respond with \fI* \s-1BAD\s0 Invalid tag\fR.
.PP
If you try to run any other mailbox method after calling idle but
before calling done, then that method will not only fail but also
take you out of the \s-1IDLE\s0 state. This means that when you eventually
remember to call \fBdone\fR you will just get that \fI* \s-1BAD\s0 Invalid tag\fR
thing again.
.Sh "examine"
.IX Subsection "examine"
Example:
.PP
.Vb 1
\&        $imap->examine($folder) or die "Could not examine: $@\en";
.Ve
.PP
The \fBexamine\fR method selects a folder in read-only mode and changes
the object's state to \*(L"Selected\*(R". The folder selected via the
\&\fBexamine\fR method can be examined but no changes can be made unless it
is first selected via the select method. 
.PP
The \fBexamine\fR method accepts one argument, which is the name of the
folder to select. 
.Sh "exists"
.IX Subsection "exists"
Example:
.PP
.Vb 1
\&        $imap->exists($folder) or warn "$folder not found: $@\en";
.Ve
.PP
Accepts one argument, a folder name. Returns true if the folder exists
or false if it does not exist.
.Sh "expunge"
.IX Subsection "expunge"
Example:
.PP
.Vb 1
\&        $imap->expunge($folder) or die "Could not expunge: $@\en";
.Ve
.PP
The \fBexpunge\fR method accepts one optional argument, a folder name. It
expunges the folder specified as the argument, or the currently
selected folder if no argument is supplied. 
.PP
Although \s-1RFC2060\s0 does not permit optional arguments (like a folder
name) to the \s-1EXPUNGE\s0 client command, the expunge method does, which
is especially interesting given that the expunge method doesn't
technically exist. In case you're curious, expunging a folder deletes
the messages that you thought were already deleted via
delete_message but really weren't, which means you have to use a
method that doesn't exist to delete messages that you thought didn't
exist. (Seriously, I'm not making any of this stuff up.)
.PP
Or you could use the close method, which de-selects as well as
expunges and which likewise doesn't technically exist.
.Sh "fetch"
.IX Subsection "fetch"
Example:
.PP
.Vb 1
\&        my $output = $imap->fetch(@args) or die "Could not fetch: $@\en";
.Ve
.PP
The \fBfetch\fR method implements the \s-1FETCH\s0 \s-1IMAP\s0 client command. It
accepts a list of arguments, which will be converted into a
space-delimited list of arguments to the \s-1FETCH\s0 \s-1IMAP\s0 client command. If
no arguments are supplied then \fBfetch\fR does a \s-1FETCH\s0 \s-1ALL\s0. If the Uid
parameter is set to a true value then the first argument will be
treated as a \s-1UID\s0 or list of \s-1UID\s0's, which means that the \s-1UID\s0 \s-1FETCH\s0 \s-1IMAP\s0
client command will be run instead of \s-1FETCH\s0. (It would really be a good
idea at this point to review \s-1RFC2060\s0.) 
.PP
If called in array context, \fBfetch\fR will return an array of output
lines. The output lines will be returned just as they were received
from the server, so your script will have to be prepared to parse out
the bits you want. The only exception to this is literal strings, which
will be inserted into the output line at the point at which they were
encountered (without the {nnn} literal field indicator). See \s-1RFC2060\s0
for a description of literal fields.
.PP
If \fBfetch\fR is called in a scalar context, then a reference to an array
(as described above) is returned instead of the entire array. 
.PP
\&\fBfetch\fR returns \f(CW\*(C`undef\*(C'\fR on failure. Inspect LastError or \f(CW$@\fR for
an explanation of your error.
.Sh "fetch_hash"
.IX Subsection "fetch_hash"
Example:
	my \f(CW$hashref\fR = {} ;
	\f(CW$imap\fR\->fetch_hash(\*(L"\s-1RFC822\s0.SIZE\*(R",$hashref) ;
	print \*(L"Msg #$m is \f(CW$hashref\fR\->{$m} bytes\en\*(R" foreach my \f(CW$m\fR (keys %$hashref);
.PP
The \fBfetch_hash\fR method accepts a list of message attributes to be fetched 
(as described in \s-1RFC2060\s0). It returns a hash whose keys are all the messages 
in the currently selected folder and whose values are key-value pairs of fetch 
keywords and the message's value for that keyword (see sample output below).
.PP
If \fBfetch_hash\fR is called in scalar context, it returns a reference to the hash
instead of the hash itself. If the last argument is a hash reference, then that 
hash reference will be used as the place where results are stored (and that 
reference will be returned upon successful completion). If the last argument is 
not a reference then it will be treated as one of the \s-1FETCH\s0 attributes and a new 
hash will be created and returned (either by value or by reference, depending on 
the context in which \fBfetch_hash\fR was called).
.PP
For example, if you have a folder with 3 messages and want the size and internal 
date for each of them, you could do the following:
.PP
.Vb 10
\&        use Mail::IMAPClient;
\&        use Data::Dumper;
\&        # ...   other code goes here
\&        $imap->select($folder);
\&        my $hash = $imap->fetch_hash("RFC822.SIZE","INTERNALDATE");
\&        # (Same as:
\&        #  my $hash = $imap->fetch_hash("RFC822.SIZE");
\&        #  $imap->fetch_hash("INTERNALDATE",$hash);
\&        # ).
\&        print Data::Dumper->Dumpxs([$hash],['$hash']);
.Ve
.PP
This would result in Data::Dumper output similar to the following:
.PP
.Vb 14
\&   $hash = {
\&        '1' => {
\&                          'INTERNALDATE' => '21-Sep-2002 18:21:56 +0000',
\&                          'RFC822.SIZE' => '1586',
\&               },
\&        '2' => {
\&                          'INTERNALDATE' => '22-Sep-2002 11:29:42 +0000',
\&                          'RFC822.SIZE' => '1945',
\&               },
\&        '3' => {
\&                          'INTERNALDATE' => '23-Sep-2002 09:16:51 +0000',
\&                          'RFC822.SIZE' => '134314',
\&               }
\&     };
.Ve
.PP
You can specify \fIBODY[\s-1HEADER\s0.FIELDS ($fieldlist)\fR as an argument, but you
should keep the following in mind if you do:
.PP
\&\fB1.\fR	You can only specify one argument of this type per call. If you need
multiple fields, then you'll have to call \fBfetch_hashref\fR multiple times, 
each time specifying a different \s-1FETCH\s0 attribute but the same.  
.PP
\&\fB2.\fR	Fetch operations that return \s-1RFC822\s0 message headers return the whole
header line, including the field name and the colon. For example, if you
do a \f(CW\*(C`$imap\->fetch_hash("BODY[HEADER.FIELDS (Subject)]")\*(C'\fR, you will
get back subject lines that start with \*(L"Subject: \*(R".
.PP
By itself this method may be useful for, say, speeding up programs that 
want the size of every message in a folder. It issues one command and 
receives one (possibly long!) response from the server. However, it's true
power lies in the as-yet-unwritten methods that will rely on this method
to deliver even more powerful result hashes (and which may even remove the
restrictions mentioned in \fB1\fR and \fB2\fR, above). Look for more new function
in later releases.
.PP
This method is new with version 2.2.3 and is thus still experimental. If you
decide to try this method and run into problems, please see the section on
\&\*(L"\s-1REPORTING\s0 \s-1BUGS\s0\*(R".
.Sh "flags"
.IX Subsection "flags"
Example:
.PP
.Vb 2
\&        my @flags = $imap->flags($msgid) 
\&                or die "Could not flags: $@\en";
.Ve
.PP
The \fBflags\fR method implements the \s-1FETCH\s0 \s-1IMAP\s0 client command to list a
single message's flags. It accepts one argument, a message sequence
number (or a message \s-1UID\s0, if the Uid parameter is true), and returns
an array (or a reference to an array, if called in scalar context)
listing the flags that have been set. Flag names are provided with
leading backslashes.
.PP
As of version 1.11, you can supply either a list of message id's or a
reference to an array of of message id's (which means either sequence
number, if the Uid parameter is false, or message \s-1UID\s0's, if the Uid
parameter is true) instead of supplying a single message sequence
number or \s-1UID\s0. If you do, then the return value will not be an array or
array reference; instead, it will be a hash reference, with each key
being a message sequence number (or \s-1UID\s0) and each value being a
reference to an array of flags set for that message.
.PP
For example, if you want to display the flags for every message in the
folder where you store e\-mail related to your plans for world
domination, you could do something like this:
.PP
.Vb 6
\&        use Mail::IMAPClient;
\&        my $imap = Mail::IMAPClient->new( Server => $imaphost,
\&                                          User   => $login,
\&                                          Password=> $pass,
\&                                          Uid => 1,             # optional
\&        );
.Ve
.PP
.Vb 3
\&        $imap->select("World Domination");
\&        # get the flags for every message in my 'World Domination' folder 
\&        $flaghash = $imap->flags( scalar($imap->search("ALL"))) ;
.Ve
.PP
.Vb 5
\&        # pump through sorted hash keys to print results:
\&        for my $k (sort { $flaghash->{$a} <=> $flaghash->{$b} } keys %$flaghash) {
\&                # print: Message 1: \eFlag1, \eFlag2, \eFlag3
\&                print "Message $k:\et",join(", ",@{$flaghash->{$k}}),"\en";
\&        }
.Ve
.Sh "folders"
.IX Subsection "folders"
Example:
.PP
.Vb 1
\&        $imap->folders  or die "Could not list folders: $@\en";
.Ve
.PP
The \fBfolders\fR method returns an array listing the available folders.
It will only be successful if the object is in the \fIAuthenticated\fR or
\&\fISelected\fR states.
.PP
The \fBfolders\fR argument accepts one optional argument, which is a prefix.
If a prefix is supplied to the \fBfolders\fR method, then only folders beginning 
with the prefix will be returned. 
.PP
For example:
.PP
.Vb 9
\&        print join(", ",$imap->folders),".\en";
\&        # Prints: 
\&        # INBOX, Sent, Projects, Projects/Completed, Projects/Ongoing, Projects Software.
\&        print join(", ",$imap->folders("Projects"),".\en";
\&        # Prints: 
\&        # Projects, Projects/Completed, Projects/Ongoing, Projects Software.
\&        print join(", ",$imap->folders("Projects" . $imap->separator),".\en";
\&        # Prints: 
\&        # Projects/Completed, Projects/Ongoing
.Ve
.PP
Notice that if you just want to list a folder's subfolders (and not the 
folder itself), then you need to include the hierarchy separator character 
(as returned by the separator method).
.Sh "has_capability"
.IX Subsection "has_capability"
Example:
.PP
.Vb 2
\&        my $has_feature = $imap->has_capability($feature) 
\&                or die "Could not do has_capability($feature): $@\en";
.Ve
.PP
Returns true if the \s-1IMAP\s0 server to which the \fBIMAPClient\fR object is
connected has the capability specified as an argument to
\&\fBhas_capability\fR.
.Sh "idle"
.IX Subsection "idle"
Example:
.PP
.Vb 3
\&        my $idle = $imap->idle or warn "Couldn't idle: $@\en";
\&        goDoOtherThings();
\&        $imap->done($idle) or warn "Error from done: $@\en";
.Ve
.PP
The \fBidle\fR method places the \s-1IMAP\s0 connection in an \s-1IDLE\s0 state. Your
server must support the \s-1IMAP\s0 \s-1IDLE\s0 extension to use this method. (See
\&\s-1RFC2177\s0 for a discussion of the \s-1IDLE\s0 \s-1IMAP\s0 extension.) The \fBidle\fR method
accepts no arguments and returns a transaction number. This transaction 
number must be supplied as the argument for done when the done
method is later called.
.PP
Use the done method to tell the \s-1IMAP\s0 server that the connection is 
finished idling. 
.PP
If you attempt to use the \fBidle\fR method against a server that does not
have the \s-1IDLE\s0 capability then the \fBidle\fR method will return \f(CW\*(C`undef\*(C'\fR.
If you then attempt to use the \fBidle\fR method a second time the \fBidle\fR 
method will return \f(CW\*(C`undef\*(C'\fR again.
.PP
If you successfully run the \fBidle\fR method, then you must use the done
method to stop idling (or to continue, in the parlance of \s-1RFC2177\s0). 
Failure to do so will only encourage your server to call you \fI\s-1BAD\s0\fR 
and to rant about a \fIBogus \s-1IDLE\s0 continuation\fR.
.PP
If you try to run any other mailbox method after calling idle but
before calling done, then that method will not only fail but also
take you out of the \s-1IDLE\s0 state. This means that when you eventually
remember to call \fBdone\fR you will just get an \fI* \s-1BAD\s0 Invalid tag\fR
message.
.Sh "imap4rev1"
.IX Subsection "imap4rev1"
Example:
.PP
.Vb 1
\&        $imap->imap4rev1 or die "Could not imap4rev1: $@\en";
.Ve
.PP
Returns true if the \s-1IMAP\s0 server to which the \fBIMAPClient\fR object is
connected has the \s-1IMAP4REV1\s0 capability.
.Sh "internaldate"
.IX Subsection "internaldate"
Example:
.PP
.Vb 2
\&        my $msg_internal_date = $imap->internaldate($msgid) 
\&                or die "Could not internaldate: $@\en";
.Ve
.PP
\&\fBinternaldate\fR accepts one argument, a message id (or \s-1UID\s0 if the
Uid parameter is true), and returns that message's internal date.
.Sh "get_bodystructure"
.IX Subsection "get_bodystructure"
Example:
.PP
.Vb 2
\&        my $bodyStructObject = $imap->get_bodystructure($msgid) 
\&                or die "Could not get_bodystructure: $@\en";
.Ve
.PP
The \fBget_bodystructure\fR method accepts one argument, a message
sequence number or, if Uid is true, a message \s-1UID\s0. It obtains the
message's body structure and returns a parsed
Mail::IMAPClient::BodyStructure object for the message.
.Sh "get_envelope"
.IX Subsection "get_envelope"
Example:
.PP
.Vb 2
\&        my $envObject = $imap->get_envelope(@args) 
\&                or die "Could not get_envelope: $@\en";
.Ve
.PP
The \fBget_envelope\fR method accepts one argument, a message sequence
number or, if Uid is true, a message \s-1UID\s0. It obtains the message's
envelope and returns a \fBMail::IMAPClient::BodyStructure::Envelope\fR
object for the envelope, which is just a version of the envelope that's
been parsed into a perl object.
.PP
For more information on how to use this object once you've gotten it,
see the Mail::IMAPClient::BodyStructure documention. (As of this
writing there is no separate pod document for
\&\fBMail::IMAPClient::BodyStructure::Envelope\fR.)
.Sh "getacl"
.IX Subsection "getacl"
Example:
.PP
.Vb 2
\&        my $hash = $imap->getacl($folder) 
\&                or die "Could not getacl for $folder: $@\en";
.Ve
.PP
\&\fBgetacl\fR accepts one argument, the name of a folder. If no argument is
provided then the currently selected folder is used as the default. It
returns a reference to a hash. The keys of the hash are userids that
have access to the folder, and the value of each element are the
permissions for that user. The permissions are listed in a string in
the order returned from the server with no whitespace or punctuation
between them.
.Sh "get_header"
.IX Subsection "get_header"
Example:
.PP
.Vb 1
\&        my $messageId = $imap->get_header($msg, "Message-Id") ;
.Ve
.PP
The \fBget_header\fR method accepts two arguments, a message sequence number
or \s-1UID\s0 and the name of an \s-1RFC822\s0 header (without the trailing colon). It returns 
the value for that header in the message whose sequence number or \s-1UID\s0
was passed as the first argument. If no value can be found it returns \f(CW\*(C`undef\*(C'\fR;
if multiple values are found it returns the first one. Its return value is 
always a scalar. \fBget_header\fR uses case insensitive matching to get the value,
so you do not have to worry about the case of your second argument.
.PP
The \fBget_header\fR method is a short-cut for:
.PP
.Vb 1
\&        my $messageId = $imap->parse_headers($msg,"Subject")->{"Subject"}[0];
.Ve
.Sh "is_parent"
.IX Subsection "is_parent"
Example:
.PP
.Vb 1
\&        my $hasKids = $imap->is_parent($folder) ;
.Ve
.PP
The \fBis_parent\fR method accepts one argument, the name of a folder. It
returns a value that indicates whether or not the folder has children.
The value it returns is either 1) a true value (indicating that the
folder has children), 2) 0 if the folder has no children at this time,
or 3) \f(CW\*(C`undef\*(C'\fR if the folder is not permitted to have children.
.PP
Eg:
.PP
.Vb 10
\&        my $parenthood = $imap->is_parent($folder);
\&        if (defined($parenthood)) { 
\&                if ($parenthood) {
\&                        print "$folder has children.\en" ;
\&                } else {
\&                        print "$folder is permitted children, but has none.\en";
\&                }
\&        } else {
\&                print "$folder is not permitted to have children.\en";
\&        }
.Ve
.Sh "list"
.IX Subsection "list"
Example:
.PP
.Vb 2
\&        my @raw_output = $imap->list(@args) 
\&                or die "Could not list: $@\en";
.Ve
.PP
The \fBlist\fR method implements the \s-1IMAP\s0 \s-1LIST\s0 client command. Arguments
are passed to the \s-1IMAP\s0 server as received, separated from each other by
spaces. If no arguments are supplied then the default list command
\&\f(CW\*(C`tag LIST "" '*'\*(C'\fR is issued.
.PP
The \fBlist\fR method returns an array (or an array reference, if called
in a scalar context). The array is the unadulterated output of the \s-1LIST\s0
command. (If you want your output adulterated then see the folders
method, above.)
.Sh "listrights"
.IX Subsection "listrights"
Example:
.PP
.Vb 2
\&        $imap->listrights($folder,$user) 
\&                or die "Could not listrights: $@\en";
.Ve
.PP
The \fBlistrights\fR method implements the \s-1IMAP\s0 \s-1LISTRIGHTS\s0 client command
(\s-1RFC2086\s0). It accepts two arguments, the foldername and a user id.
It returns the rights the specified user has for the specified folder.
If called in a scalar context then the rights are returned a strings, with
no punction or whitespace or any nonsense like that. If called in array
context then \fBlistrights\fR returns an array in which each element is one
right.
.Sh "login"
.IX Subsection "login"
Example:
.PP
.Vb 1
\&        $imap->login or die "Could not login: $@\en";
.Ve
.PP
The \fBlogin\fR method uses the \s-1IMAP\s0 \s-1LOGIN\s0 client command (as defined in
\&\s-1RFC2060\s0) to log into the server. The \fIUser\fR and \fIPassword\fR parameters
must be set before the \fBlogin\fR method can be invoked. If successful,
the \fBlogin\fR method returns a pointer to the \fBIMAPClient\fR object and
sets the object status to \fIAuthenticated\fR. If unsuccessful, it returns
undef. See the new method for more information on how \fBlogin\fR can
be called automatically from new.
.PP
\&\fBlogin\fR is sometimes called automatically by connect, which in turn
is sometimes called automatically by new. You can predict this 
behavior once you've read the section on the new method.
.PP
Then Sun/iPlanet/Netscape \s-1IMAP\s0 servers to allow an administrative user to
masquerade as another user.  The \fBproxyauth\fR method uses the \s-1IMAP\s0
\&\s-1PROXYAUTH\s0 client command provided like this:
.PP
.Vb 2
\&      $imap->login("admin", "password");
\&      $imap->proxyauth("someuser");
.Ve
.Sh "logout"
.IX Subsection "logout"
Example:
.PP
.Vb 1
\&        $imap->logout or die "Could not logout: $@\en";
.Ve
.PP
The \fBlogout\fR method issues the \s-1LOGOUT\s0 \s-1IMAP\s0 client commmand. Since the
\&\s-1LOGOUT\s0 \s-1IMAP\s0 client command causes the server to end the connection,
this also results in the \fBIMAPClient\fR client entering the
\&\fIUnconnected\fR state. This method does not, however, destroy the
\&\fBIMAPClient\fR object, so a program can re-invoke the connect and
login methods if it wishes to reestablish a session later in the
program.
.PP
According to the standard, a well-behaved client should log out before
closing the socket connection. Therefore, \fBMail::IMAPClient\fR will 
attempt to log out of the server during \fB\s-1DESTROY\s0\fR processing if the
object being destroyed is in the Connected state.
.Sh "lsub"
.IX Subsection "lsub"
Example:
.PP
.Vb 1
\&        $imap->lsub(@args) or die "Could not lsub: $@\en";
.Ve
.PP
The \fBlsub\fR method implements the \s-1IMAP\s0 \s-1LSUB\s0 client command. Arguments
are passed to the \s-1IMAP\s0 server as received, separated from each other
by spaces. If no arguments are supplied then the default lsub command
\&\f(CW\*(C`tag LSUB "" '*'\*(C'\fR is issued.
.PP
The \fBlsub\fR method returns an array (or an array reference, if called
in a scalar context). The array is the unaltered output of the \s-1LSUB\s0
command. If you want an array of subscribed folders then see the
subscribed method, below.
.Sh "mark"
.IX Subsection "mark"
Example:
.PP
.Vb 1
\&        $imap->mark(@msgs) or die "Could not mark: $@\en";
.Ve
.PP
The \fBmark\fR method accepts a list of one or more messages sequence
numbers, or a single reference to an array of one or more message
sequence numbers, as its argument(s). It then sets the \*(L"\eFlagged\*(R" flag
for those message(s). Of course, if the Uid parameter is set to a
true value then those message sequence numbers had better be unique
message id's.
.PP
Note that specifying \f(CW\*(C`$imap\->see(@msgs)\*(C'\fR is just a shortcut for
specifying \f(CW\*(C`$imap\->set_flag("Flagged",@msgs)\*(C'\fR. 
.Sh "Massage"
.IX Subsection "Massage"
Example:
.PP
.Vb 1
\&        $imap->search(HEADER => 'Message-id' => $imap->Massage($msg_id,1));
.Ve
.PP
The \fBMassage\fR method accepts a value as an argument and, optionally, a second 
value that, when true, indicates that the first argument is not the name of an 
existing folder.
.PP
It returns its argument as a correctly quoted string or a literal string.
.PP
Note that you should rarely use this on folder names, since methods that accept
folder names as an argument will call \fBMassage\fR for you. In fact, it was originally 
developed as an undocumented helper method meant for internal Mail::IMAPClient methods 
only. 
.PP
You may also want to see the Quote method, which is related to this method.
.Sh "message_count"
.IX Subsection "message_count"
Example:
.PP
.Vb 2
\&        my $msgcount = $imap->message_count($folder); 
\&        defined($msgcount) or die "Could not message_count: $@\en";
.Ve
.PP
The \fBmessage_count\fR method accepts the name of a folder as an argument
and returns the number of messages in that folder. Internally, it
invokes the status method (see above) and parses out the results to
obtain the number of messages. If you don't supply an argument to
\&\fBmessage_count\fR then it will return the number of messages in the
currently selected folder (assuming of course that you've used the
select or examine method to select it instead of trying something
funky). Note that \s-1RFC2683\s0 contains warnings about the use of the \s-1IMAP\s0
\&\fI\s-1STATUS\s0\fR command (and thus the status method and therefore the 
\&\fBmessage_count\fR method) against the currenlty selected folder.
You should carefully consider this before using \fBmessage_count\fR 
on the currently selected folder. You may be better off using 
search or one of its variants (especially messages), and then
counting the results. On the other hand, I regularly violate this
rule on my server without suffering any dire consequences. Your 
milage may vary.
.Sh "message_string"
.IX Subsection "message_string"
Example:
.PP
.Vb 2
\&        my $string = $imap->message_string($msgid) 
\&                or die "Could not message_string: $@\en";
.Ve
.PP
The \fBmessage_string\fR method accepts a message sequence number (or
message \s-1UID\s0 if Uid is true) as an argument and returns the message
as a string. The returned value contains the entire message in one
scalar variable, including the message headers. Note that using this
method will set the message's \*(L"\eSeen\*(R" flag as a side effect, unless
\&\fIPeek\fR is set to a true value.
.Sh "message_to_file"
.IX Subsection "message_to_file"
Example:
.PP
.Vb 2
\&        $imap->message_to_file($file,@msgs) 
\&                or die "Could not message_to_file: $@\en";
.Ve
.PP
The \fBmessage_to_file\fR method accepts a filename or file handle and one
or more message sequence numbers (or message UIDs if Uid is true) as
arguments and places the message string(s) (including \s-1RFC822\s0 headers)
into the file named in the first argument (or prints them to the
filehandle, if a filehandle is passed). The returned value is true on
succes and \f(CW\*(C`undef\*(C'\fR on failure. 
.PP
If the first argument is a reference, it is assumed to be an open
filehandle and will not be closed when the method completes, If it is a
file, it is opened in append mode, written to, then closed.
.PP
Note that using this method will set the message's \*(L"\eSeen\*(R" flag as a
side effect. But you can use the deny_seeing method to set it back,
or set the Peek parameter to a true value to prevent setting the
\&\*(L"\eSeen\*(R" flag at all.
.PP
This method currently works by making some basic assumptions about the
server's behavior, notably that the message text will be returned as a
literal string but that nothing else will be. If you have a better idea
then I'd like to hear it. 
.Sh "message_uid"
.IX Subsection "message_uid"
Example:
.PP
.Vb 2
\&        my $msg_uid = $imap->message_uid($msg_seq_no) 
\&                or die "Could not get uid for $msg_seq_no: $@\en";
.Ve
.PP
The \fBmessage_uid\fR method accepts a message sequence number (or message
\&\s-1UID\s0 if Uid is true) as an argument and returns the message's \s-1UID\s0.
Yes, if Uid is true then it will use the \s-1IMAP\s0 \s-1UID\s0 \s-1FETCH\s0 \s-1UID\s0 client
command to obtain and return the very same argument you supplied. This
is an \s-1IMAP\s0 feature so don't complain to me about it.
.Sh "messages"
.IX Subsection "messages"
Example:
.PP
.Vb 4
\&        # Get a list of messages in the current folder:
\&        my @msgs = $imap->messages or die "Could not messages: $@\en";
\&        # Get a reference to an array of messages in the current folder:
\&        my $msgs = $imap->messages or die "Could not messages: $@\en";
.Ve
.PP
If called in list context, the \fBmessages\fR method returns a list of all
the messages in the currenlty selected folder. If called in scalar
context, it returns a reference to an array containing all the messages
in the folder. If you have the Uid parameter turned off, then this
is the same as specifying \f(CW\*(C`1 ... $imap\->message_count\*(C'\fR; if you
have \s-1UID\s0 set to true then this is the same as specifying
\&\f(CW\*(C`$imap\->search("ALL")\*(C'\fR. 
.Sh "migrate"
.IX Subsection "migrate"
Example:
.PP
.Vb 2
\&        $imap->migrate($imap_2, "ALL", $targetFolder ) 
\&                or die "Could not migrate: $@\en";
.Ve
.PP
The \fBmigrate\fR method copies the indicated messages \fBfrom\fR the
currently selected folder \fBto\fR another \fBMail::IMAPClient\fR object's
session. It requires these arguments:
.IP "1." 4
a reference to the target \fBMail::IMAPClient\fR object (not the calling
object, which is connected to the source account);
.IP "2." 4
the message(s) to be copied, specified as either a) the message
sequence number (or message \s-1UID\s0 if the \s-1UID\s0 parameter is true) of a
single message, b) a reference to an array of message sequence numbers
(or message \s-1UID\s0's if the \s-1UID\s0 parameter is true) or c) the special
string \*(L"\s-1ALL\s0\*(R", which is a shortcut for the results of
\&\f(CW\*(C`search("ALL")\*(C'\fR.
.IP "3." 4
the folder name of a folder on the target mailbox to receive the
message(s). If this argument is not supplied or if \fIundef\fR is supplied
then a folder with the same name as the currently selected folder on
the calling object will be created if necessary and used. If you
specify something other then \fIundef\fR for this argument, even if it's
\&'$imap1\->Folder' or the name of the currently selected folder, then
that folder will only be used if it exists on the target object's
mailbox; if it does not exist then \fBmigrate\fR will fail.
.PP
The target \fBMail::IMAPClient\fR object should not be the same as the
source. The source object is the calling object, i.e. the one whose
\&\fBmigrate\fR method will be used. It cannot be the same object as the one
specified as the target, even if you are for some reason migrating
between folders on the same account (which would be silly anyway, since
copy can do that much more efficiently). If you try to use the same
\&\fBMail::IMAPClient\fR object for both the caller and the reciever then
they'll both get all screwed up and it will be your fault because I
just warned you and you didn't listen.
.PP
\&\fBmigrate\fR will download messages from the source in chunks to minimize
memory usage. The size of the chunks can be controlled by changing the
source \fBMail::IMAPClient\fR object's the Buffer parameter. The higher
the Buffer value, the faster the migration, but the more memory your
program will require. \s-1TANSTAAFL\s0. (See the Buffer parameter and
eponymous accessor method, described above under the \*(L"Parameters\*(R"
section.)
.PP
The \fBmigrate\fR method uses Black Magic to hardwire the I/O between the
two \fBMail::IMAPClient\fR objects in order to minimize resource
consumption. If you have older scripts that used message_to_file and
append_file to move large messages between \s-1IMAP\s0 mailboxes then you
may want to try this method as a possible replacement.
.PP
See also \f(CW\*(C`Supportedflags\*(C'\fR.
.Sh "move"
.IX Subsection "move"
Example:
.PP
.Vb 3
\&        my $newUid = $imap->move($newFolder, $oldUid) 
\&                or die "Could not move: $@\en";
\&        $imap->expunge;
.Ve
.PP
The \fBmove\fR method moves messages from the currently selected folder to
the folder specified in the first argument to \fBmove\fR. If the Uid
parameter is not true, then the rest of the arguments should be either:
.IP ">" 4
a message sequence number,
.IP ">" 4
a comma-separated list of message sequence numbers, or
.IP ">" 4
a reference to an array of message sequence numbers.
.PP
If the Uid parameter is true, then the arguments should be:
.IP ">" 4
a message \s-1UID\s0,
.IP ">" 4
a comma-separated list of message \s-1UID\s0's, or
.IP ">" 4
a reference to an array of message \s-1UID\s0's.
.PP
If the target folder does not exist then it will be created.
.PP
If move is sucessful, then it returns a true value. Furthermore, if the
\&\fBMail::IMAPClient\fR object is connected to a server that has the
\&\s-1UIDPLUS\s0 capability, then the true value will be the comma-separated
list of \s-1UID\s0's for the newly copied messages. The list will be in the
order in which the messages were moved. (Since \fBmove\fR uses the copy
method, the messages will be moved in numerical order.)
.PP
If the move is not successful then \fBmove\fR returns \f(CW\*(C`undef\*(C'\fR.
.PP
Note that a move really just involves copying the message to the new
folder and then setting the \fI\eDeleted\fR flag. To actually delete the
original message you will need to run expunge (or close).
.Sh "namespace"
.IX Subsection "namespace"
Example:
.PP
.Vb 2
\&        my @refs = $imap->namespace
\&                or die "Could not namespace: $@\en";
.Ve
.PP
The namespace method runs the \s-1NAMESPACE\s0 \s-1IMAP\s0 command (as defined in \s-1RFC\s0
2342). When called in a list context, it returns a list of three
references. Each reference looks like this:
.PP
.Vb 4
\&        [ [ $prefix_1, $separator_1 ] , 
\&          [ $prefix_2, $separator_2 ], 
\&          [ $prefix_n , $separator_n] 
\&        ]
.Ve
.PP
The first reference provides a list of prefices and separator
charactors for the available personal namespaces. The second reference
provides a list of prefices and separator charactors for the available
shared namespaces. The third reference provides a list of prefices and
separator charactors for the available public namespaces.
.PP
If any of the three namespaces are unavailable on the current server
then an 'undef' is returned instead of a reference. So for example if
shared folders were not supported on the server but personal and public
namespaces were both available (with one namespace each), the returned
value might resemble this: 
.PP
.Vb 1
\&        ( [ "", "/" ] , undef, [ "#news", "." ] ) ;
.Ve
.PP
If the \fBnamespace\fR method is called in scalar context, it returns a
reference to the above-mentioned list of three references, thus
creating a single structure that would pretty-print something like
this:
.PP
.Vb 17
\&        $VAR1 = [
\&                        [ 
\&                                [ $user_prefix_1, $user_separator_1 ] , 
\&                                [ $user_prefix_2, $user_separator_2], 
\&                                [ $user_prefix_n , $user_separator_n] 
\&                        ]       ,                                       # or undef
\&                        [ 
\&                                [ $shared_prefix_1, $shared_separator_1 ] , 
\&                                [ $shared_prefix_2, $shared_separator_2], 
\&                                [ $shared_prefix_n , $shared_separator_n] 
\&                        ]       ,                                       # or undef
\&                        [ 
\&                                [ $public_prefix_1, $public_separator_1 ] , 
\&                                [ $public_prefix_2, $public_separator_2], 
\&                                [ $public_prefix_n , $public_separator_n] 
\&                        ]       ,                                       # or undef
\&        ];
.Ve
.PP
Or, to look at our previous example (where shared folders are
unsupported) called in scalar context:
.PP
.Vb 7
\&        $VAR1 = [
\&                        [
\&                                [
\&                                        "" ,
\&                                        "/",
\&                                ],
\&                        ],
.Ve
.PP
.Vb 1
\&                        undef,
.Ve
.PP
.Vb 7
\&                        [
\&                                [
\&                                        "#news",                
\&                                        "." 
\&                                ],
\&                        ],
\&        ];
.Ve
.Sh "on"
.IX Subsection "on"
Example:
.PP
.Vb 2
\&        my @msgs = $imap->on($Rfc2060_date) 
\&                or warn "Could not find messages sent on $Rfc2060_date: $@\en";
.Ve
.PP
The \fBon\fR method works just like the since method, below, except it
returns a list of messages whose internal system dates are the same as
the date supplied as the argument.
.Sh "parse_headers"
.IX Subsection "parse_headers"
Example:
.PP
.Vb 2
\&        my $hashref = $imap->parse_headers($msg||@msgs, "Date", "Subject") 
\&                or die "Could not parse_headers: $@\en";
.Ve
.PP
The \fBparse_headers\fR method accepts as arguments a message sequence
number and a list of header fields. It returns a hash reference in
which the keys are the header field names (without the colon) and the
values are references to arrays of values. A picture would look
something like this:
.PP
.Vb 19
\&   $hashref = $imap->parse_headers(1,"Date","Received","Subject","To");
\&   $hashref = {
\&        "Date"          => [ "Thu, 09 Sep 1999 09:49:04 -0400" ]  ,
\&        "Received"      => [ q/
\&                from mailhub ([111.11.111.111]) by mailhost.bigco.com 
\&                (Netscape Messaging Server 3.6)  with ESMTP id AAA527D for 
\&                <bigshot@bigco.com>; Fri, 18 Jun 1999 16:29:07 +0000
\&                /, q/
\&                from directory-daemon by mailhub.bigco.com (PMDF V5.2-31 #38473)
\&                id <0FDJ0010174HF7@mailhub.bigco.com> for bigshot@bigco.com
\&                (ORCPT rfc822;big.shot@bigco.com); Fri, 18 Jun 1999 16:29:05 +0000 (GMT)
\&                /, q/
\&                from someplace ([999.9.99.99]) by smtp-relay.bigco.com (PMDF V5.2-31 #38473) 
\&                with ESMTP id <0FDJ0000P74H0W@smtp-relay.bigco.com> for big.shot@bigco.com; Fri,
\&                18 Jun 1999 16:29:05 +0000 (GMT)
\&                /] ,
\&        "Subject"       => [ qw/ Help! I've fallen and I can't get up!/ ] ,
\&        "To"            => [ "Big Shot <big.shot@bigco.com> ] ,
\&        } ;
.Ve
.PP
The text in the example for the \*(L"Received\*(R" array has been formated to
make reading the example easier. The actual values returned are just
strings of words separated by spaces and with newlines and carriage
returns stripped off. The \fIReceived\fR header is probably the main
reason that the \fBparse_headers\fR method creates a hash of lists rather
than a hash of values. 
.PP
If the second argument to \fBparse_headers\fR is '\s-1ALL\s0' or if it is
unspecified then all available headers are included in the returned
hash of lists.
.PP
If you're not emotionally prepared to deal with a hash of lists then
you can always call the fetch method yourself with the appropriate
parameters and parse the data out any way you want to. Also, in the
case of headers whose contents are also reflected in the envelope, you
can use the get_envelope method as an alternative to
parse_headers.
.PP
If the Uid parameter is true then the first argument will be treated
as a message \s-1UID\s0. If the first argument is a reference to an array of
message sequence numbers (or \s-1UID\s0's if Uid is true), then
\&\fBparse_headers\fR will be run against each message in the array. In this
case the return value is a hash, in which the key is the message
sequence number (or \s-1UID\s0) and the value is a reference to a hash as
described above.
.PP
An example of using \fBparse_headers\fR to print the date and subject of
every message in your smut folder could look like this:
.PP
.Vb 6
\&        use Mail::IMAPClient;
\&        my $imap = Mail::IMAPClient->new( Server => $imaphost,
\&                                          User   => $login,
\&                                          Password=> $pass,
\&                                          Uid => 1,             # optional
\&        );
.Ve
.PP
.Vb 1
\&        $imap->select("smut");
.Ve
.PP
.Vb 1
\&        for my $h (
.Ve
.PP
.Vb 4
\&         # grab the Subject and Date from every message in my (fictional!) smut folder;
\&         # the first argument is a reference to an array listing all messages in the folder
\&         # (which is what gets returned by the $imap->search("ALL") method when called in
\&         # scalar context) and the remaining arguments are the fields to parse out
.Ve
.PP
.Vb 9
\&         # The key is the message number, which in this case we don't care about:
\&         values %{$imap->parse_headers( scalar($imap->search("ALL")) , "Subject", "Date")}
\&        ) {
\&                # $h is the value of each element in the hash ref returned from parse_headers,
\&                # and $h is also a reference to a hash.
\&                # We'll only print the first occurance of each field because we don't expect more
\&                # than one Date: or Subject: line per message.
\&                 print map { "$_:\et$h->{$_}[0]\en"} keys %$h ; 
\&        }
.Ve
.Sh "recent"
.IX Subsection "recent"
Example:
.PP
.Vb 1
\&        my @recent = $imap->recent or warn "No recent msgs: $@\en";
.Ve
.PP
The \fBrecent\fR method performs an \s-1IMAP\s0 \s-1SEARCH\s0 \s-1RECENT\s0 search against the
selected folder and returns an array of sequence numbers (or \s-1UID\s0's, if
the Uid parameter is true) of messages that are recent.
.Sh "recent_count"
.IX Subsection "recent_count"
Example:
.PP
.Vb 3
\&        my $count = 0;
\&        defined($count = $imap->recent_count($folder)) 
\&                or die "Could not recent_count: $@\en";
.Ve
.PP
The \fBrecent_count\fR method accepts as an argument a folder name. It
returns the number of recent messages in the folder (as returned by the
\&\s-1IMAP\s0 client command \*(L"\s-1STATUS\s0 folder \s-1RECENT\s0\*(R"), or \f(CW\*(C`undef\*(C'\fR in the case of an
error. The \fBrecent_count\fR method was contributed by Rob Deker
(deker@ikimbo.com).
.Sh "rename"
.IX Subsection "rename"
Example:
.PP
.Vb 2
\&        $imap->rename($oldname,$nedwname) 
\&                or die "Could not rename: $@\en";
.Ve
.PP
The \fBrename\fR method accepts two arguments: the name of an existing
folder, and a new name for the folder. The existing folder will be
renamed to the new name using the \s-1RENAME\s0 \s-1IMAP\s0 client command. \fBrename\fR
will return a true value if successful, or \f(CW\*(C`undef\*(C'\fR if unsuccessful.
.Sh "restore_message"
.IX Subsection "restore_message"
Example:
.PP
.Vb 1
\&        $imap->restore_message(@msgs) or die "Could not restore_message: $@\en";
.Ve
.PP
The \fBrestore_message\fR method is used to undo a previous
delete_message operation (but not if there has been an intervening
expunge or close). The \fBIMAPClient\fR object must be in
Selected status to use the \fBrestore_message\fR method. 
.PP
The \fBrestore_message\fR method accepts a list of arguments. If the
Uid parameter is not set to a true value, then each item in the list
should be either:
.IP ">" 4
a message sequence number,
.IP ">" 4
a comma-separated list of message sequence numbers,
.IP ">" 4
a reference to an array of message sequence numbers, or
.PP
If the Uid parameter is set to a true value, then each item in the
list should be either:
.IP ">" 4
a message \s-1UID\s0,
.IP ">" 4
a comma-separated list of \s-1UID\s0's, or
.IP ">" 4
a reference to an array of message \s-1UID\s0's.
.PP
The messages identified by the sequence numbers or \s-1UID\s0's will have
their \fI\eDeleted\fR flags cleared, effectively \*(L"undeleting\*(R" the messages.
\&\fBrestore_message\fR returns the number of messages it was able to
restore. 
.PP
Note that \fBrestore_messages\fR is similar to calling
\&\f(CW\*(C`unset_flag("\eDeleted",@msgs)\*(C'\fR, except that \fBrestore_messages\fR
returns a (slightly) more meaningful value. Also it's easier to type.
.Sh "run"
.IX Subsection "run"
Example:
.PP
.Vb 1
\&        $imap->run(@args) or die "Could not run: $@\en";
.Ve
.PP
The \fBrun\fR method is provided to make those uncommon things
possible... however, we would like you to contribute the knowledge
of missing features with us.
.PP
The \fBrun\fR method excepts one or two arguments. The first argument is a
string containing an \s-1IMAP\s0 Client command, including a tag and all
required arguments. The optional second argument is a string to look
for that will indicate success. (The default is \f(CW\*(C`/OK.*/\*(C'\fR). The \fBrun\fR
method returns an array of output lines from the command, which you are
free to parse as you see fit.
.PP
The \fBrun\fR method does not do any syntax checking, other than
rudimentary checking for a tag.
.PP
When \fBrun\fR processes the command, it increments the transaction count
and saves the command and responses in the History buffer in the same
way other commands do. However, it also creates a special entry in the
History buffer named after the tag supplied in the string passed as the
first argument. If you supply a numeric value as the tag then you may
risk overwriting a previous transaction's entry in the History buffer.
.PP
If you want the control of \fBrun\fR but you don't want to worry about the
damn tags then see \*(L"tag_and_run\*(R", below.
.Sh "search"
.IX Subsection "search"
Example:
.PP
.Vb 4
\&        my @msgs = $imap->search(@args) or warn "search: None found\en";
\&        if ($@) {
\&                warn "Error in search: $@\en";
\&        }
.Ve
.PP
The \fBsearch\fR method implements the \s-1SEARCH\s0 \s-1IMAP\s0 client command. Any
argument supplied to \fBsearch\fR is prefixed with a space and appended to
the \s-1SEARCH\s0 \s-1IMAP\s0 client command. This method is another one of those
situations where it will really help to have your copy of \s-1RFC2060\s0
handy, since the \s-1SEARCH\s0 \s-1IMAP\s0 client command contains a plethora of
options and possible arguments. I'm not going to repeat them here. 
.PP
Remember that if your argument needs quotes around it then you must
make sure that the quotes will be preserved when passing the argument.
I.e. use \f(CW\*(C`qq/"$arg"/\*(C'\fR instead of \f(CW"$arg"\fR. When in doubt, use the
Quote method.
.PP
The \fBsearch\fR method returns an array containing sequence numbers of
messages that passed the \s-1SEARCH\s0 \s-1IMAP\s0 client command's search criteria.
If the Uid parameter is true then the array will contain message
\&\s-1UID\s0's. If \fBsearch\fR is called in scalar context then a pointer to the
array will be passed, instead of the array itself. If no messages meet
the criteria then \fBsearch\fR returns an empty list (when in list context)
or \f(CW\*(C`undef\*(C'\fR (in scalar context).
.PP
Since a valid, successful search can legitimately return zero matches,
you may wish to distinguish between a search that correctly returns 
zero hits and a search that has failed for some other reason (i.e. 
invalid search parameters).  Therefore, the \f(CW$@\fR variable will always 
be cleared before the \fI\s-1SEARCH\s0\fR command is issued to the server, and 
will thus remain empty unless the server gives a \fI\s-1BAD\s0\fR or \fI\s-1NO\s0\fR response 
to the \fI\s-1SEARCH\s0\fR command. 
.Sh "see"
.IX Subsection "see"
Example:
.PP
.Vb 1
\&        $imap->see(@msgs) or die "Could not see: $@\en";
.Ve
.PP
The \fBsee\fR method accepts a list of one or more messages sequence
numbers, or a single reference to an array of one or more message
sequence numbers, as its argument(s). It then sets the \fI\eSeen\fR flag
for those message(s). Of course, if the Uid parameter is set to a
true value then those message sequence numbers had better be unique
message id's, but then you already knew that, didn't you?
.PP
Note that specifying \f(CW\*(C`$imap\->see(@msgs)\*(C'\fR is just a shortcut for
specifying \f(CW\*(C`$imap\->set_flag("Seen",@msgs)\*(C'\fR. 
.Sh "seen"
.IX Subsection "seen"
Example:
.PP
.Vb 1
\&        my @seenMsgs = $imap->seen or warn "No seen msgs: $@\en";
.Ve
.PP
The \fBseen\fR method performs an \s-1IMAP\s0 \s-1SEARCH\s0 \s-1SEEN\s0 search against the
selected folder and returns an array of sequence numbers of messages
that have already been seen (ie their \fI\eSeen\fR flag is set). If the
Uid parameter is true then an array of message \s-1UID\s0's will be
returned instead. If called in scalar context than a reference to the
array (rather than the array itself) will be returned.
.Sh "select"
.IX Subsection "select"
Example:
.PP
.Vb 1
\&        $imap->select($folder) or die "Could not select: $@\en";
.Ve
.PP
The \fBselect\fR method selects a folder and changes the object's state to
\&\fISelected\fR. It accepts one argument, which is the name of the folder
to select.
.Sh "selectable"
.IX Subsection "selectable"
Example:
.PP
.Vb 3
\&        foreach my $f ( grep($imap->selectable($_),$imap->folders ) ) {
\&                $imap->select($f) ;
\&        }
.Ve
.PP
The \fBselectable\fR method accepts one value, a folder name, and returns true
if the folder is selectable or false if it is not selectable.
.Sh "sentbefore"
.IX Subsection "sentbefore"
Example:
.PP
.Vb 2
\&        my @msgs = $imap->sentbefore($Rfc2060_date) 
\&                or warn "Could not find any msgs sent before $Rfc2060_date: $@\en";
.Ve
.PP
The \fBsentbefore\fR method works just like \*(L"sentsince\*(R", below, except it
searches for messages that were sent before the date supplied as an
argument to the method.
.Sh "senton"
.IX Subsection "senton"
Example:
.PP
.Vb 2
\&        my @msgs = $imap->senton($Rfc2060_date) 
\&                or warn "Could not find any messages sent on $Rfc2060_date: $@\en";
.Ve
.PP
The \fBsenton\fR method works just like \*(L"sentsince\*(R", below, except it searches
for messages that were sent on the exact date supplied as an argument
to the method.
.Sh "sentsince"
.IX Subsection "sentsince"
Example:
.PP
.Vb 2
\&        my @msgs = $imap->sentsince($Rfc2060_date) 
\&                or warn "Could not find any messages sent since $Rfc2060_date: $@\en";
.Ve
.PP
The \fBsentsince\fR method accepts one argument, a date in either epoch
time format (seconds since 1/1/1970, or as output by time 
and as accepted by localtime) 
or in the \fIdate_text\fR format as defined in \s-1RFC2060\s0 (dd\-Mon\-yyyy, where Mon 
is the English-language three-letter abbreviation for the month). 
.PP
It searches for items in the currently selected folder for messages
sent since the day whose date is provided as the argument. It uses the
\&\s-1RFC822\s0 \fIDate:\fR header to determine the \fIsentsince\fR date. (Actually,
it the server that uses the \fIDate:\fR header; this documentation just
assumes that the date is coming from the \fIDate:\fR header because that's
what \s-1RFC2060\s0 dictates.)
.PP
In the case of arguments supplied as a number of seconds, the returned
result list will include items sent on or after that day, regardless of
whether they arrived before the specified time on that day. The \s-1IMAP\s0
protocol does not support searches at a granularity finer than a day,
so neither do I. On the other hand, the only thing I check for in a
\&\fIdate_text\fR argument is that it matches the pattern
\&\f(CW\*(C`/\ed\ed\-\eD\eD\eD\-\ed\ed\ed\ed/\*(C'\fR (notice the lack of anchors), so if your
server lets you add something extra to a \fIdate_text\fR string then so
will \fBMail::IMAPClient\fR.
.PP
If you'd like, you can use the Rfc2060_date method to convert from
epoch time (as returned by time) into an \s-1RFC2060\s0 date
specification.
.Sh "separator"
.IX Subsection "separator"
Example:
.PP
.Vb 2
\&        my $sepChar = $imap->separator(@args) 
\&                or die "Could not get separator: $@\en";
.Ve
.PP
The \fBseparator\fR method returns the character used as a separator
character in folder hierarchies. On unix-based servers, this is often
but not necessarily a forward slash (/). It accepts one argument, the
name of a folder whose hierarchy's separator should be returned. If no
folder name is supplied then the separator for the \s-1INBOX\s0 is returned,
which probably is good enough.
.PP
If you want your programs to be portable from \s-1IMAP\s0 server brand X to
\&\s-1IMAP\s0 server brand Y, then you should never use hard-coded separator
characters to specify subfolders. (In fact, it's even more complicated
than that, since some server don't allow any subfolders at all, some
only allow subfolders under the \*(L"\s-1INBOX\s0\*(R" folder, and some forbid
subfolders in the inbox but allow them \*(L"next\*(R" to the inbox.
Furthermore, some server implementations do not allow folders to
contain both subfolders and mail messages; other servers allow this.)
.Sh "set_flag"
.IX Subsection "set_flag"
Example:
.PP
.Vb 2
\&        $imap->set_flag("Seen",@msgs) 
\&                or die "Could not set flag: $@\en";
.Ve
.PP
The \fBset_flag\fR method accepts the name of a flag as its first argument
and a list of one or more messages sequence numbers, or a single
reference to an array of one or more message sequence numbers, as its
next argument(s). It then sets the flag specified for those message(s).
Of course, if the Uid parameter is set to a true value then those
message sequence numbers had better be unique message id's, just as
you'd expect.
.PP
Note that when specifying the flag in question, the preceding backslash
(\e) is entirely optional. (For you, that is. \fBMail::IMAPClient\fR still
has remember to stick it in there before passing the command to the
server if the flag is one of the reserved flags specified in \s-1RFC2060\s0.
This is in fact so important that the method checks its argument and
adds the backslash when necessary, which is why you don't have to worry
about it overly much.)
.Sh "setacl"
.IX Subsection "setacl"
Example:
.PP
.Vb 2
\&        $imap->setacl($folder,$userid,$authstring) 
\&                or die "Could not set acl: $@\en";
.Ve
.PP
The \fBsetacl\fR method accepts three input arguments, a folder name, a
user id (or authentication identifier, to use the terminology of
\&\s-1RFC2086\s0), and an access rights modification string. See \s-1RFC2086\s0 for
more information. (This is somewhat experimental and its implementation
may change.)
.Sh "since"
.IX Subsection "since"
Example:
.PP
.Vb 2
\&        my @msgs = $imap->since($date) 
\&                or warn "Could not find any messages since $date: $@\en";
.Ve
.PP
The \fBsince\fR method accepts a date in either epoch format
(seconds since 1/1/1970, or as output by \*(L"time\*(R" in perlfunc and as
accepted by \*(L"localtime\*(R" in perlfunc) or in the \fIdate_text\fR format as
defined in \s-1RFC2060\s0 (dd\-Mon\-yyyy, where Mon is the English-language
three-letter abbreviation for the month). It searches for items in the
currently selected folder for messages whose internal dates are on or
after the day whose date is provided as the argument. It uses the
internal system date for a message to determine if that message was
sent since the given date.
.PP
In the case of arguments supplied as a number of seconds, the returned
result list will include items whose internal date is on or after that
day, regardless of whether they arrived before the specified time on
that day. 
.PP
If \fBsince\fR is called in a list context then it will return a list of 
messages meeting the \fI\s-1SEARCH\s0 \s-1SINCE\s0\fR criterion, or an empty list if
no messages meet the criterion.
.PP
If \fBsince\fR is called in a scalar context then it will return 
a reference to an array of messages meeting the \fI\s-1SEARCH\s0 \s-1SINCE\s0\fR 
criterion, or \f(CW\*(C`undef\*(C'\fR if no messages meet the criterion.
.PP
Since \fBsince\fR is a front-end to search, some of the same rules apply.
For example, the \f(CW$@\fR variable will always be cleared before the \fI\s-1SEARCH\s0\fR
command is issued to the server, and will thus remain empty unless 
the server gives a \fI\s-1BAD\s0\fR or \fI\s-1NO\s0\fR response to the \fI\s-1SEARCH\s0\fR command.
.Sh "size"
.IX Subsection "size"
Example:
.PP
.Vb 2
\&        my $size = $imap->size($msgId) 
\&                or die "Could not find size of message $msgId: $@\en";
.Ve
.PP
The \fBsize\fR method accepts one input argument, a sequence number (or
message \s-1UID\s0 if the Uid parameter is true). It returns the size of
the message in the currently selected folder with the supplied sequence
number (or \s-1UID\s0). The \fBIMAPClient\fR object must be in a \fISelected\fR
state in order to use this method.
.Sh "sort"
.IX Subsection "sort"
Example:
.PP
.Vb 4
\&        my @msgs = $imap->sort(@args) ;
\&        if ($@ ) {
\&                warn "Error in sort: $@\en";
\&        }
.Ve
.PP
The \fBsort\fR method is just like the search method, only different.
It implements the \s-1SORT\s0 extension as described in
<http://search.ietf.org/internet\-drafts/draft\-ietf\-imapext\-sort\-10.txt>.
It would be wise to use the has_capability method to verify that the
\&\s-1SORT\s0 capability is available on your server before trying to use the
\&\fBsort\fR method. If you forget to check and you're connecting to a
server that doesn't have the \s-1SORT\s0 capability then \fBsort\fR will return
undef. LastError will then say you are \*(L"\s-1BAD\s0\*(R". If your server doesn't
support the \s-1SORT\s0 capability then you'll have to use search and then
sort the results yourself.
.PP
The first argument to \fBsort\fR is a space-delimited list of sorting
criteria. The Internet Draft that describes \s-1SORT\s0 requires that this
list be wrapped in parentheses, even if there is only one sort
criterion. If you forget the parentheses then the \fBsort\fR method will
add them. But you have to forget both of them, or none. This isn't \s-1CMS\s0
running under \s-1VM\s0!
.PP
The second argument is a character set to use for sorting. Different
character sets use different sorting orders, so this argument is
important. Since all servers must support \s-1UTF\-8\s0 and US-ASCII if they
support the \s-1SORT\s0 capability at all, you can use one of those if you
don't have some other preferred character set in mind.
.PP
The rest of the arguments are searching criteria, just as you would
supply to the search method. These are all documented in \s-1RFC2060\s0. If
you just want all of the messages in the currently selected folder
returned to you in sorted order, use \fI\s-1ALL\s0\fR as your only search
criterion.
.PP
The \fBsort\fR method returns an array containing sequence numbers of
messages that passed the \s-1SORT\s0 \s-1IMAP\s0 client command's search criteria. If
the Uid parameter is true then the array will contain message \s-1UID\s0's.
If \fBsort\fR is called in scalar context then a pointer to the array will
be passed, instead of the array itself. The message sequence numbers or
unique identifiers are ordered according to the sort criteria
specified. The sort criteria are nested in the order specified; that
is, items are sorted first by the first criterion, and within the first
criterion they are sorted by the second criterion, and so on.
.PP
The sort method will clear \f(CW$@\fR before attempting the \fI\s-1SORT\s0\fR
operation just as the search method does.
.Sh "status"
.IX Subsection "status"
Example:
.PP
.Vb 2
\&        my @rawdata = $imap->status($folder,qw/(Messages)/) 
\&                or die "Error obtaining status: $@\en";
.Ve
.PP
The \fBstatus\fR method accepts one argument, the name of a folder (or
mailbox, to use \s-1RFC2060\s0's terminology), and returns an array containing
the results of running the \s-1IMAP\s0 \s-1STATUS\s0 client command against that
folder. If additional arguments are supplied then they are appended to
the \s-1IMAP\s0 \s-1STATUS\s0 client command string, separated from the rest of the
string and each other with spaces.
.PP
If \fBstatus\fR is not called in an array context then it returns a
reference to an array rather than the array itself.
.PP
The \fBstatus\fR method should not be confused with the \fBStatus\fR method
(with an uppercase 'S'), which returns information about the
\&\fBIMAPClient\fR object. (See the section labeled \*(L"Status Methods\*(R",
below).
.Sh "store"
.IX Subsection "store"
Example:
.PP
.Vb 1
\&        $imap->store(@args) or die "Could not store: $@\en";
.Ve
.PP
The \fBstore\fR method accepts a message sequence number or
comma-separated list of message sequence numbers as a first argument, a
message data item name, and a value for the message data item.
Currently, data items are the word \*(L"\s-1FLAGS\s0\*(R" followed by a space and a
list of flags (in parens). The word \*(L"\s-1FLAGS\s0\*(R" can be modified by
prefixing it with either a \*(L"+\*(R" or a \*(L"\-\*(R" (to indicate \*(L"add these flags\*(R"
or \*(L"remove these flags\*(R") and by suffixing it with \*(L".SILENT\*(R" (which
reduces the amount of output from the server; very useful with large
message sets). Normally you won't need to call \fBstore\fR because there
are oodles of methods that will invoke store for you with the correct
arguments. Furthermore, these methods are friendlier and more flexible
with regards to how you specify your arguments. See for example see,
deny_seeing, delete_message, and restore_message. Or mark,
unmark, set_flag, and unset_flag.
.Sh "subject"
.IX Subsection "subject"
Example:
.PP
.Vb 1
\&        my $subject = $imap->subject($msg);
.Ve
.PP
The \fBsubject\fR method accepts one argument, a message sequence number (or a 
message \s-1UID\s0, if the \fIUid\fR parameter is true). The text in the \*(L"Subject\*(R" header
of that message is returned (without the \*(L"Subject: \*(R" prefix). This method is
a short-cut for:
.PP
.Vb 1
\&        my $subject = $imap->get_header($msg, "Subject");
.Ve
.Sh "subscribed"
.IX Subsection "subscribed"
Example:
.PP
.Vb 2
\&        my @subscribedFolders = $imap->subscribed 
\&                or warn "Could not find subscribed folders: $@\en";
.Ve
.PP
The \fBsubscribed\fR method works like the \fBfolders\fR method, above,
except that the returned list (or array reference, if called in scalar
context) contains only the subscribed folders. 
.PP
Like folders, you can optionally provide a prefix argument to the 
\&\fBsubscribed\fR method.
.Sh "tag_and_run"
.IX Subsection "tag_and_run"
Example:
.PP
.Vb 2
\&        my @output = $imap->tag_and_run(@args) 
\&                or die "Could not tag_and_run: $@\en";
.Ve
.PP
The \fBtag_and_run\fR method accepts one or two arguments. The first
argument is a string containing an \s-1IMAP\s0 Client command, without a tag
but with all required arguments. The optional second argument is a
string to look for that will indicate success (without pattern
delimiters). The default is \f(CW\*(C`OK.*\*(C'\fR. 
.PP
The \fBtag_and_run\fR method will prefix your string (from the first
argument) with the next transaction number and run the command. It
returns an array of output lines from the command, which you are free
to parse as you see fit. Using this method instead of \fBrun\fR (above)
will free you from having to worry about handling the tags (and from
worrying about the side affects of naming your own tags).
.Sh "uidnext"
.IX Subsection "uidnext"
Example:
.PP
.Vb 1
\&        my $nextUid = $imap->uidnext($folder) or die "Could not uidnext: $@\en";
.Ve
.PP
The \fBuidnext\fR method accepts one argument, the name of a folder, and
returns the numeric string that is the next available message \s-1UID\s0 for
that folder.
.Sh "thread"
.IX Subsection "thread"
Example: 
.PP
.Vb 1
\&        my $thread = $imap->thread($algorythm, $charset, @search_args ) ;
.Ve
.PP
The \fBthread\fR method accepts zero to three arguments. The first argument is the
threading algorythm to use, generally either \fI\s-1ORDEREDSUBJECT\s0\fR or \fI\s-1REFERENCES\s0\fR.
The second argument is the character set to use, and the third argument is the
set of search arguments to use.
.PP
If the algorythm is not supplied, it defaults to \fI\s-1REFERENCES\s0\fR if available, or
\&\fI\s-1ORDEREDSUBJECT\s0\fR if available. If neither of these is available then the 
\&\fBthread\fR method returns undef.
.PP
If the character set is not specified it will default to \fI\s-1UTF\-8\s0\fR.
.PP
If the search arguments are not specified, the default is \fI\s-1ALL\s0\fR.
.PP
If \fBthread\fR is called for an object connected to a server that does not support
the \s-1THREADS\s0 extension then the \fBthread\fR method will return \f(CW\*(C`undef\*(C'\fR.
.PP
The \fBthreads\fR method will issue the \fI\s-1THREAD\s0\fR command as defined in 
<http://www.ietf.org/internet\-drafts/draft\-ietf\-imapext\-thread\-11.txt>.
It returns an array of threads. Each element in the array is either a message
id or a reference to another array of (sub)threads.
.PP
If the Uid parameter is set to a true value then the message id's returned 
in the thread structure will be message \s-1UID\s0's. Otherwise they will be message
sequence numbers.
.Sh "uidvalidity"
.IX Subsection "uidvalidity"
Example:
.PP
.Vb 2
\&        my $validity = $imap->uidvalidity($folder) 
\&                or die "Could not uidvalidity: $@\en";
.Ve
.PP
The \fBuidvalidity\fR method accepts one argument, the name of a folder,
and returns the numeric string that is the unique identifier validity
value for the folder.
.Sh "unmark"
.IX Subsection "unmark"
Example:
.PP
.Vb 1
\&        $imap->unmark(@msgs) or die "Could not unmark: $@\en";
.Ve
.PP
The \fBunmark\fR method accepts a list of one or more messages sequence
numbers, or a single reference to an array of one or more message
sequence numbers, as its argument(s). It then unsets the \fI\eFlagged\fR
flag for those message(s). Of course, if the Uid parameter is set to
a true value then those message sequence numbers should really be
unique message id's.
.PP
Note that specifying \f(CW\*(C`$imap\->unmark(@msgs)\*(C'\fR is just a shortcut for
specifying \f(CW\*(C`$imap\->unset_flag("Flagged",@msgs)\*(C'\fR. 
.PP
Note also that the \fI\eFlagged\fR flag is just one of many possible flags.
This is a little confusing, but you'll have to get used to the idea
that among the reserved flags specified in \s-1RFC2060\s0 is one name
\&\fI\eFlagged\fR. There is no specific meaning for this flag; it means
whatever the mailbox owner (or delegate) wants it to mean when it
is turned on.
.Sh "unseen"
.IX Subsection "unseen"
Example:
.PP
.Vb 1
\&        my @unread = $imap->unseen or warn "Could not find unseen msgs: $@\en";
.Ve
.PP
The \fBunseen\fR method performs an \s-1IMAP\s0 \s-1SEARCH\s0 \s-1UNSEEN\s0 search against the
selected folder and returns an array of sequence numbers of messages
that have not yet been seen (ie their \fI\eSeen\fR flag is not set). If the
Uid parameter is true then an array of message \s-1UID\s0's will be
returned instead. If called in scalar context than a pointer to the
array (rather than the array itself) will be returned.
.PP
Note that when specifying the flag in question, the preceding backslash
(\e) is entirely optional.
.Sh "unseen_count"
.IX Subsection "unseen_count"
Example:
.PP
.Vb 5
\&        foreach my $f ($imap->folders) {
\&                print   "The $f folder has ",
\&                        $imap->unseen_count($f)||0, 
\&                        " unseen messages.\en";          
\&        }
.Ve
.PP
The \fBunseen_count\fR method accepts the name of a folder as an argument
and returns the number of unseen messages in that folder. If no folder
argument is provided then it returns the number of unseen messages in
the currently selected Folder.
.Sh "unset_flag"
.IX Subsection "unset_flag"
Example:
.PP
.Vb 2
\&        $imap->unset_flag("\eSeen",@msgs) 
\&                or die "Could not unset_flag: $@\en";
.Ve
.PP
The \fBunset_flag\fR method accepts the name of a flag as its first
argument and a list of one or more messages sequence numbers, or a
single reference to an array of one or more message sequence numbers,
as its next argument(s). It then unsets the flag specified for those
message(s). Of course, if the Uid parameter is set to a true value
then those message sequence numbers had better be unique message id's,
just as you'd expect.
.SH "Other IMAP Client Commands"
.IX Header "Other IMAP Client Commands"
Until release \fB2.99\fR, when you called a method which did not exist,
they where automatically translated into an \s-1IMAP\s0 call with the same
name via an \s-1AUTOLOAD\s0 hack.  This \*(L"feature\*(R" was removed for various
reasons: people made typos in the capatization of method names, and the
program still seemed to work correctly.  Besides, it blocked further
development of this module, because people did not contribute their
private extensions to the protocol implementation.
.Sh "copy($msg,$folder)"
.IX Subsection "copy($msg,$folder)"
Copy a message from the currently selected folder in the the folder
whose name is in \f(CW$folder\fR
.Sh "subscribe($folder)"
.IX Subsection "subscribe($folder)"
Subscribe to a folder
.PP
\&\fB\s-1CAUTION:\s0\fR Once again, remember to quote your quotes (or use the
Quote method) if you want quotes to be part of the \s-1IMAP\s0 command 
string. 
.PP
You can also use the default method to override the behavior of
implemented \s-1IMAP\s0 methods by changing the case of the method name,
preferably to all-uppercase so as not to conflict with the Class method
and accessor method namespace. For example, if you don't want the
search method's behavior (which returns a list of message numbers)
but would rather have an array of raw data returned from your search
operation, you can issue the following snippet:
.PP
.Vb 1
\&        my @raw = $imap->SEARCH("SUBJECT","Whatever...");
.Ve
.PP
which is slightly more efficient than the equivalent:
.PP
.Vb 1
\&        $imap->search("SUBJECT","Whatever...");
.Ve
.PP
.Vb 1
\&        my @raw = $imap->Results;
.Ve
.PP
Of course you probably want the search results tucked nicely into a list
for you anyway, in which case you might as well use the search method.
.SH "Parameters"
.IX Header "Parameters"
There are several parameters that influence the behavior of an
\&\fBIMAPClient\fR object. Each is set by specifying a named value pair
during new method invocation as follows:
.PP
.Vb 4
\&        my $imap = Mail::IMAPClient->new ( parameter  => "value",
\&                               parameter2 => "value",
\&                                ...
\&        );
.Ve
.PP
Parameters can also be set after an object has been instantiated by
using the parameter's eponymous accessor method like this:
.PP
.Vb 3
\&        my $imap = Mail::IMAPClient->new;
\&           $imap->parameter( "value");
\&           $imap->parameter2("value");
.Ve
.PP
The eponymous accessor methods can also be used without arguments to
obtain the current value of the parameter as follows:
.PP
.Vb 3
\&        my $imap = Mail::IMAPClient->new;
\&           $imap->parameter( "value");
\&           $imap->parameter2("value");
.Ve
.PP
.Vb 2
\&                ...     # A whole bunch of awesome perl code, 
\&                        # omitted for brevity
.Ve
.PP
.Vb 2
\&           my $forgot  = $imap->parameter;
\&           my $forgot2 = $imap->parameter2;
.Ve
.PP
Note that in these examples I'm using 'parameter' and 'parameter2' as
generic parameter names. The \fBIMAPClient\fR object doesn't actually have
parameters named 'parameter' and 'parameter2'. On the contrary, the
available parameters are:
.Sh "Authmechanism"
.IX Subsection "Authmechanism"
Example:
.PP
.Vb 3
\&                $imap->Authmechanism("CRAM-MD5");
\&                # or
\&                my $authmech = $imap->Authmechanism();
.Ve
.PP
If specified, the \fIAuthmechanism\fR causes the specified authentication
mechanism to be used whenever \fBMail::IMAPClient\fR would otherwise invoke
\&\fBlogin\fR. If the value specified for the \fIAuthmechanism\fR parameter is not
a valid authentication mechanism for your server then you will never ever
be able to log in again for the rest of your perl script, probably. So you
might want to check, like this:
.PP
.Vb 2
\&        my $authmech = "CRAM-MD5";
\&        $imap->has_capability($authmech) and $imap->Authmechanism($authmech);
.Ve
.PP
Of course if you know your server supports your favorite authentication 
mechanism then you know, so you can then include your \fIAuthmechanism\fR 
with your \fBnew\fR call, as in:
.PP
.Vb 7
\&        my $imap = Mail::IMAPClient->new(
\&                        User    => $user,
\&                        Passord => $passord,
\&                        Server  => $server,
\&                        Authmechanism  => $authmech,
\&                        %etc 
\&        );
.Ve
.PP
If \fIAuthmechanism\fR is supplied but \fIAuthcallback\fR is not then you had better be
supporting one of the authentication mechanisms that \fBMail::IMAPClient\fR supports
\&\*(L"out of the box\*(R" (such as \s-1CRAM\-MD5\s0).
.Sh "Authcallback"
.IX Subsection "Authcallback"
Example:
.PP
.Vb 1
\&                $imap->Authcallback( \e&callback );
.Ve
.PP
This specifies a default callback to the default authentication mechanism
(see Authmechanism, above). Together, these two methods replace automatic
calls to login with automatic calls that look like this (sort of):
.PP
.Vb 1
\&        $imap->authenticate($imap->Authmechanism,$imap->Authcallback) ;
.Ve
.PP
If \fIAuthmechanism\fR is supplied but \fIAuthcallback\fR is not then you had better be
supporting one of the authentication mechanisms that \fBMail::IMAPClient\fR supports
\&\*(L"out of the box\*(R" (such as \s-1CRAM\-MD5\s0).
.Sh "Buffer"
.IX Subsection "Buffer"
Example:
.PP
.Vb 3
\&        $Buffer = $imap->Buffer();
\&        # or:
\&        $imap->Buffer($new_value);
.Ve
.PP
The \fIBuffer\fR parameter sets the size of a block of I/O. It is ignored
unless Fast_io, below, is set to a true value (the default), or
unless you are using the migrate method. It's value should be the
number of bytes to attempt to read in one I/O operation. The default
value is 4096.
.PP
When using the migrate method, you can often achieve dramatic
improvements in throughput by adjusting this number upward. However,
doing so also entails a memory cost, so if set too high you risk losing
all the benefits of the migrate method's chunking algorythm. Your
program can thus terminate with an \*(L"out of memory\*(R" error and you'll
have no one but yourself to blame.
.PP
Note that, as hinted above, the \fIBuffer\fR parameter affects the
behavior of the migrate method regardless of whether you have
Fast_io turned on. Believe me, you don't want to go around migrating
tons of mail without using buffered I/O! 
.Sh "Clear"
.IX Subsection "Clear"
Example:
.PP
.Vb 3
\&        $Clear = $imap->Clear();
\&        # or:
\&        $imap->Clear($new_value);
.Ve
.PP
The name of this parameter, for historical reasons, is somewhat
misleading. It should be named \fIWrap\fR, because it specifies how many
transactions are stored in the wrapped history buffer. But it didn't
always work that way; the buffer used to actually get cleared. The name
though remains the same in the interests of backwards compatibility.
Also I'm too lazy to change it.
.PP
\&\fIClear\fR specifies that the object's history buffer should be wrapped
after every \fIn\fR transactions, where \fIn\fR is the value specified for
the \fIClear\fR parameter. Calling the eponymous \fBClear\fR method without
an argument will return the current value of the \fIClear\fR parameter but
will not cause clear the history buffer to wrap. 
.PP
Setting \fIClear\fR to 0 turns off automatic history buffer wrapping, and
setting it to 1 turns off the history buffer facility (except for the
last transaction, which cannot be disabled without breaking the
\&\fBIMAPClient\fR module). Setting \fIClear\fR to 0 will not cause an
immediate clearing of the history buffer; setting it to 1 (or any other
number) will (except of course for that inevitable last transaction). 
.PP
The default \fIClear\fR value is set to five in order to conserve memory.
.Sh "Debug"
.IX Subsection "Debug"
Example:
.PP
.Vb 3
\&        $Debug = $imap->Debug();
\&        # or:
\&        $imap->Debug($true_or_false);
.Ve
.PP
Sets the debugging flag to either a true or false value. Can be
supplied with the new method call or separately by calling the
\&\fBDebug\fR object method. Use of this parameter is strongly recommended
when debugging scripts and required when reporting bugs.
.Sh "Debug_fh"
.IX Subsection "Debug_fh"
Example:
.PP
.Vb 3
\&        $Debug_fh = $imap->Debug_fh();
\&        # or:
\&        $imap->Debug_fh($fileHandle);
.Ve
.PP
Specifies the filehandle to which debugging information should be
printed. It can either a filehandle object reference or a filehandle
glob. The default is to print debugging info to \s-1STDERR\s0.
.PP
For example, you can:
.PP
.Vb 9
\&        use Mail::IMAPClient;
\&        use IO::File;
\&        # set $user, $pass, and $server here
\&        my $dh = IO::File->new(">debugging.output") 
\&                or die "Can't open debugging.output: $!\en";
\&        my $imap = Mail::IMAPClient->new(       User=>$user, Password=>$pass, 
\&                                                Server=>$server, Debug=> "yes, please",
\&                                                Debug_fh => $dh
\&        );
.Ve
.PP
which is the same as:
.PP
.Vb 10
\&        use Mail::IMAPClient;
\&        use IO::File;
\&        # set $user, $pass, and $server here
\&        my $imap = Mail::IMAPClient->new(       User    =>$user, 
\&                                                Password=>$pass, 
\&                                                Server  =>$server, 
\&                                                Debug   => "yes, please",
\&                                                Debug_fh=> IO::File->new(">debugging.output") || 
\&                                                        die "Can't open debugging.output: $!\en"
\&        );
.Ve
.PP
You can also:
.PP
.Vb 8
\&        use Mail::IMAPClient;
\&        # set $user, $pass, and $server here
\&        open(DBG,">debugging.output") 
\&                or die "Can't open debugging.output: $!\en";
\&        my $imap = Mail::IMAPClient->new(       User=>$user, Password=>$pass, 
\&                                                Server=>$server, Debug=> 1,
\&                                                Debug_fh => *DBG
\&        );
.Ve
.PP
Specifying this parameter is not very useful unless Debug is set 
to a true value.
.Sh "EnableServerResponseInLiteral"
.IX Subsection "EnableServerResponseInLiteral"
Removed in 2.99_01 (now autodetect)
.Sh "Fast_io"
.IX Subsection "Fast_io"
Example:
.PP
.Vb 3
\&        $Fast_io = $imap->Fast_io();
\&        # or:
\&        $imap->Fast_io($true_or_false);
.Ve
.PP
The \fIFast_io\fR parameter controlls whether or not your
\&\fBMail::IMAPClient\fR object will attempt to use buffered (i.e. \*(L"Fast\*(R")
I/O. It is turned on by default. If you turn it off you will definately
slow down your program, often to a painfull degree. However, if you are
experience problems you may want to try this just to see if it helps.
If it does then that means you have found a bug and should report it
immediately (by following the instructions in the section on
\&\*(L"\s-1REPORTING\s0 \s-1BUGS\s0\*(R"). Even if it doesn't fix the problem, testing with
both \fIFast_io\fR turned on and with it turned off will often aid in
identifying the source of the problem. (If it doesn't help you, it may
help me when you report it!)
.PP
Lately there have not been any bugs associated with \fIFast_io\fR so this
parameter may become deprecated in the future.
.Sh "Folder"
.IX Subsection "Folder"
Example:
.PP
.Vb 3
\&        $Folder = $imap->Folder();
\&        # or:
\&        $imap->Folder($new_value);
.Ve
.PP
The \fIFolder\fR parameter returns the name of the currently-selected
folder (in case you forgot). It can also be used to set the name of the
currently selected folder, which is completely unnecessary if you used
the select method (or select's read-only equivalent, the
examine method) to select it. 
.PP
Note that setting the \fIFolder\fR parameter does not automatically select 
a new folder; you use the select or examine object methods for that. 
Generally, the \fIFolder\fR parameter should only be queried (by using the 
no-argument form of the \fBFolder\fR method). You will only need to set the 
\&\fIFolder\fR parameter if you use some mysterious technique of your own for
selecting a folder, which you probably won't do.
.Sh "Maxtemperrors"
.IX Subsection "Maxtemperrors"
Example:
.PP
.Vb 3
\&        $Maxtemperrors = $imap->Maxtemperrors();
\&        # or:
\&        $imap->Maxtemperrors($new_value);
.Ve
.PP
The \fIMaxtemperrors\fR parameter specifies the number of times a write
operation is allowed to fail on a \*(L"Resource Temporarily Available\*(R"
error. These errors can occur from time to time if the server is too
busy to empty out its read buffer (which is logically the \*(L"other end\*(R"
of the client's write buffer). By default, \fBMail::IMAPClient\fR will
retry an unlimited number of times, but you can adjust this 
behavior by setting \fIMaxtemperrors\fR. Note that after each temporary 
error, the server will wait for a number of seconds equal to the number 
of consecutive temporary errors times .25, so very high values for 
\&\fIMaxtemperrors\fR can slow you down in a big way if your \*(L"temporary 
error\*(R" is not all that temporary.
.PP
You can set this parameter to \*(L"\s-1UNLIMITED\s0\*(R" to ignore \*(L"Resource
Temporarily Unavailable\*(R" errors. This is the default.
.Sh "Password"
.IX Subsection "Password"
Example:
.PP
.Vb 3
\&        $Password = $imap->Password();
\&        # or:
\&        $imap->Password($new_value);
.Ve
.PP
Specifies the password to use when logging into the \s-1IMAP\s0 service on the
host specified in the \fIServer\fR parameter as the user specified in the
\&\fIUser\fR parameter. Can be supplied with the \fBnew\fR method call or
separately by calling the \fBPassword\fR object method.
.PP
If \fIServer\fR, \fIUser\fR, and \fIPassword\fR are all provided to the new
method, then the newly instantiated object will be connected to the
host specified in \fIServer\fR (at either the port specified in \fIPort\fR or
the default port 143) and then logged on as the user specified in the
\&\fIUser\fR parameter (using the password provided in the \fIPassword\fR
parameter). See the discussion of the \*(L"new\*(R" method, below.
.Sh "Peek"
.IX Subsection "Peek"
Example:
.PP
.Vb 3
\&        $Peek = $imap->Peek();
\&        # or:
\&        $imap->Peek($true_or_false);
.Ve
.PP
Setting \fIPeek\fR to a true value will prevent the body_string,
message_string and message_to_file methods from automatically
setting the \fI\eSeen\fR flag. Setting \*(L"Peek\*(R" to 0 (zero) will force
\&\*(L"body_string\*(R", \*(L"message_string\*(R", \*(L"message_to_file\*(R", and
\&\*(L"parse_headers\*(R" to always set the \fI\eSeen\fR flag. 
.PP
The default is to set the seen flag whenever you fetch the body of a
message but not when you just fetch the headers. Passing \fIundef\fR to
the eponymous \fBPeek\fR method will reset the \fIPeek\fR parameter to its
pristine, default state. 
.Sh "Port"
.IX Subsection "Port"
Example:
.PP
.Vb 3
\&        $Port = $imap->Port();
\&        # or:
\&        $imap->Port($new_value);
.Ve
.PP
Specifies the port on which the \s-1IMAP\s0 server is listening. The default
is 143, which is the standard \s-1IMAP\s0 port. Can be supplied with the
new method call or separately by calling the Port object method.
.Sh "Prewritemethod"
.IX Subsection "Prewritemethod"
Specifies a method to call if your authentication mechanism requires you to
to do pre-write processing of the data sent to the server. If defined, then the
\&\fIPrewritemethod\fR parameter should contain a reference to a subroutine that 
will do Special Things to data before it is sent to the \s-1IMAP\s0 server (such as
encryption or signing).
.PP
This method will be called immediately prior to sending an \s-1IMAP\s0 client command
to the server. Its first argument is a reference to the \fIMail::IMAPClient\fR object
and the second argument is a string containing the command that will be sent to
the server. Your \fIPrewritemethod\fR should return a string that has been signed or
encrypted or whatever; this returned string is what will actually be sent to the
server.
.PP
Your \fIPrewritemethod\fR will probably need to know more than this to do whatever it does. 
It is recommended that you tuck all other pertinent information into a hash, and store a 
reference to this hash somewhere where your method can get to it, possibly in the 
\&\fIMail::IMAPClient\fR object itself.
.PP
Note that this method should not actually send anything over the socket connection to 
the server; it merely converts data prior to sending.
.PP
If you need a \fIPrewritemethod\fR then you probably need a Readmethod as well.
.Sh "Ranges"
.IX Subsection "Ranges"
Example:
.PP
.Vb 8
\&        $imap->Ranges(1);
\&        # or:
\&        my $search = $imap->search(@search_args);
\&        if ( $imap->Ranges) {   # $search is a MessageSet object
\&                print "This is my condensed search result: $search\en";
\&                print "This is every message in the search result: ",
\&                        join(",",@$search),"\en;
\&        }
.Ve
.PP
If set to a true value, then the search method will return a
Mail::IMAPClient::MessageSet object if called in a scalar context,
instead of the array reference that \fBfetch\fR normally returns when called
in a scalar context. If set to zero or if undefined, then \fBsearch\fR
will continue to return an array reference when called in scalar context.
.PP
This parameter has no affect on the \fBsearch\fR method when \fBsearch\fR
is called in a list context.
.Sh "RawSocket"
.IX Subsection "RawSocket"
Example:
        \f(CW$socket\fR = \f(CW$imap\fR\->RawSocket;
        # or:
        \f(CW$imap\fR\->RawSocket($socketh);
.PP
The \fIRawSocket\fR method can be used to obtain the socket handle of the
current connection (say, to do I/O on the connection that is not
otherwise supported by \fBMail::IMAPClient\fR) or to replace the current
socket with a new handle (for instance an \s-1SSL\s0 handle, see
IO::Socket::SSL, but be sure to see the Socket method as well).
.PP
If you supply a socket handle yourself, either by doing something like:
.PP
.Vb 1
\&        $imap=Mail::IMAPClient->new(RawSocket => $sock, User => ... );
.Ve
.PP
or by doing something like:
.PP
.Vb 4
\&        $imap = Mail::IMAPClient->new(User => $user,
\&                    Password => $pass, Server => $host);
\&        # blah blah blah
\&        $imap->RawSocket($ssl);
.Ve
.PP
then it will be up to you to establish the connection \s-1AND\s0 to
authenticate, either via the login method, or the fancier
authenticate, or, since you know so much anyway, by just doing raw
I/O against the socket until you're logged in. If you do any of this
then you should also set the State parameter yourself to reflect the
current state of the object (i.e. Connected, Authenticated, etc).
.PP
Note that no operation will be attempted on the socket when this method
is called. In particular, after the \s-1TCP\s0 connections towards the \s-1IMAP\s0
server is established, the protocol mandates the server to send an
initial greeting message, and you will have to explicitly cope with
this message before doing any other operation, e.g. trying to call
login. Caveat emptor.
.PP
For a more \s-1DWIM\s0 approach to setting the socket see Socket.
.Sh "Readmethod \s-1IMAP\s0, \s-1BUFFER\s0, \s-1LENGTH\s0, \s-1OFFSET\s0"
.IX Subsection "Readmethod IMAP, BUFFER, LENGTH, OFFSET"
This parameter, if supplied, should contain a reference to a subroutine
that will replace sysreads. The subroutine will be passed the following
arguments: first the used Mail::IMAPClient object. As second,
a reference to a scalar variable into which data is readl the \s-1BUFFER\s0. The
data place in here should be \*(L"finished data\*(R", so if you are decrypting
or removing signatures then be sure to do that before you place data
into this buffer.
.PP
As third, the number of bytes requested to be read; the \s-1LENGTH\s0 of the
request.  Finally, the \s-1OFFSET\s0 into the \s-1BUFFER\s0 where the data should be
read. If not supplied it should default to zero.
.PP
Note that this method completely replaces reads from the connection
to the server, so if you define one of these then your subroutine will
have to actually do the read. It is for things like this that we have
the Socket parameter and eponymous accessor method.
.PP
Your \fIReadmethod\fR will probably need to know more than this to do
whatever it does.  It is recommended that you tuck all other pertinent
information into a hash, and store a reference to this hash somewhere
where your method can get to it, possibly in the \fIMail::IMAPClient\fR
object itself.
.PP
If you need a \fIReadmethod\fR then you probably need a Prewritemethod
as well.
.Sh "Server"
.IX Subsection "Server"
Example:
.PP
.Vb 3
\&        $Server = $imap->Server();
\&        # or:
\&        $imap->Server($hostname);
.Ve
.PP
Specifies the hostname or \s-1IP\s0 address of the host running the \s-1IMAP\s0
server. If provided as part of the new method call, then the new
\&\s-1IMAP\s0 object will automatically be connected at the time of
instantiation. (See the new method, below.) Can be supplied with the
new method call or separately by calling the \fBServer\fR object
method.
.Sh "Showcredentials"
.IX Subsection "Showcredentials"
Normally debugging output will mask the login credentials when the plain
text login mechanism is used. Setting \fIShowcredentials\fR to a true value
will suppress this, so that you can see the string being passed back
and forth during plain text login. Only set this to true when you are
debugging problems with the \s-1IMAP\s0 \s-1LOGIN\s0 command, and then turn it off
right away when you're finished working on that problem.
.PP
Example:
.PP
.Vb 3
\&        print "This is very risky!\en" if $imap->Showcredentials();
\&        # or:
\&        $imap->Showcredentials(0);      # mask credentials again
.Ve
.Sh "Socket"
.IX Subsection "Socket"
\&\fB\s-1PLEASE\s0 \s-1NOTE\s0\fR
The semantics of this method has changed as of version 2.99_04 of this module.
If you need the old semantics, you now have to use RawSocket.
.PP
Example:
.PP
.Vb 3
\&        $Socket = $imap->Socket();
\&        # or:
\&        $imap->Socket($socket_fh);
.Ve
.PP
The \fISocket\fR method can be used to obtain the socket handle of the
current connection (say, to do I/O on the connection that is not
otherwise supported by \fBMail::IMAPClient\fR) or to replace the current
socket with a new handle (for instance an \s-1SSL\s0 handle, see
IO::Socket::SSL). 
.PP
If you supply a socket handle yourself, either by doing something like:
.PP
.Vb 1
\&         $imap = Mail::IMAPClient->new(Socket => $sock, User => ... );
.Ve
.PP
or by doing something like:
.PP
.Vb 3
\&         $imap = Mail::IMAPClient->new(User => $user,
\&                     Password => $pass, Server => $host);
\&         $imap->Socket($ssl);
.Ve
.PP
then it will be up to you to establish the connection, i.e. make sure
that \f(CW$ssl\fR in the example is a valid and connected socket.
.PP
This method is primarily used to provide a drop-in replacement for
IO::Socket::INET, used by connect by default. In fact, this method
is called by connect itself after having established a suitable
IO::Socket::INET socket connection towards the target server; for
this reason, this method also carries the normal operations associated
with connect, namely:
.IP "\(bu" 4
read the initial greeting message from the server;
.IP "\(bu" 4
call login if the conditions apply (see connect for details);
.IP "\(bu" 4
leave the \fIMail::IMAPClient\fR object in a suitable state.
.PP
For these reasons, the following example will work \*(L"out of the box\*(R":
.PP
.Vb 10
\&   use IO::Socket::SSL;
\&   my $imap = Mail::IMAPClient->new
\&    ( User     => 'your-username',
\&      Password => 'your-password',
\&      Socket   => IO::Socket::SSL->new
\&      (  Proto    => 'tcp',
\&         PeerAddr => 'some.imap.server',
\&         PeerPort => 993, # IMAP over SSL standard port
\&      ),
\&   );
.Ve
.PP
If you need more control over the socket, e.g. you have to implement a fancier
authentication method, see RawSocket.
.Sh "Timeout"
.IX Subsection "Timeout"
Example:
.PP
.Vb 3
\&        $Timeout = $imap->Timeout();
\&        # or:
\&        $imap->Timeout($new_value);
.Ve
.PP
Specifies the timeout value in seconds for reads. Specifying a true
value for \fITimeout\fR will prevent \fBMail::IMAPClient\fR from blocking in
a read.
.PP
Since timeouts are implemented via the perl select
operator, the \fITimeout\fR parameter may be set to a fractional number of
seconds. Not supplying a \fITimeout\fR, or (re)setting it to zero,
disables the timeout feature.
.Sh "Uid"
.IX Subsection "Uid"
Example:
.PP
.Vb 3
\&        $Uid = $imap->Uid();
\&        # or:
\&        $imap->Uid($true_or_false);
.Ve
.PP
If Uid is set to a true value (i.e. 1) then the behavior of the
fetch, search, copy, and store methods (and their
derivatives) is changed so that arguments that would otherwise be
message sequence numbers are treated as message \s-1UID\s0's and so that
return values (in the case of the search method and its derivatives)
that would normally be message sequence numbers are instead message
\&\s-1UID\s0's.
.PP
Internally this is implemented as a switch that, if turned on, causes
methods that would otherwise issue an \s-1IMAP\s0 \s-1FETCH\s0, \s-1STORE\s0, \s-1SEARCH\s0, or
\&\s-1COPY\s0 client command to instead issue \s-1UID\s0 \s-1FETCH\s0, \s-1UID\s0 \s-1STORE\s0, \s-1UID\s0 \s-1SEARCH\s0,
or \s-1UID\s0 \s-1COPY\s0, respectively. The main difference between message sequence
numbers and message \s-1UID\s0's is that, according to \s-1RFC2060\s0, \s-1UID\s0's must not
change during a session and should not change between sessions, and
must never be reused. Sequence numbers do not have that same guarantee
and in fact may be reused right away. 
.PP
Since foldernames also have a unique identifier (\s-1UIDVALIDITY\s0), which is
provided when the folder is selected or examined or by doing
something like \*(L"$imap\->status($folder,\*(R"\s-1UIDVALIDITY\s0"), it is possible to
uniquely identify every message on the server, although normally you
won't need to bother.
.PP
The methods currently affected by turning on the Uid flag are:
.PP
.Vb 6
\&        copy            fetch
\&        search          store 
\&        message_string  message_uid
\&        body_string     flags
\&        move            size
\&        parse_headers   thread
.Ve
.PP
Note that if for some reason you only want the Uid parameter turned
on for one command, then you can choose between the following two
snippets, which are equivalent:
.PP
Example 1:
.PP
.Vb 3
\&        $imap->Uid(1);
\&        my @uids = $imap->search('SUBJECT',"Just a silly test"); # 
\&        $imap->Uid(0);
.Ve
.PP
Example 2:
.PP
.Vb 7
\&        my @uids; 
\&        foreach $r ($imap->UID("SEARCH","SUBJECT","Just a silly test") {
\&               chomp $r;
\&               $r =~ s/\er$//;
\&               $r =~ s/^\e*\es+SEARCH\es+// or next;
\&               push @uids, grep(/\ed/,(split(/\es+/,$r)));
\&        }
.Ve
.PP
In the second example, we used the default method to issue the \s-1UID\s0 \s-1IMAP\s0
Client command, being careful to use an all-uppercase method name so as
not to inadvertently call the Uid accessor method. Then we parsed
out the message UIDs manually, since we don't have the benefit of the
built-in search method doing it for us.
.PP
Please be very careful when turning the Uid parameter on and off
throughout a script. If you loose track of whether you've got the
Uid parameter turned on you might do something sad, like deleting
the wrong message. Remember, like all eponymous accessor methods, the
\&\fBUid\fR method without arguments will return the current value for the
Uid parameter, so do yourself a favor and check. The safest approach
is probably to turn it on at the beginning (or just let it default to
being on) and then leave it on. (Remember that leaving it turned off
can lead to problems if changes to a folder's contents cause
resequencing.) 
.PP
By default, the Uid parameter is turned on.
.Sh "User"
.IX Subsection "User"
Example:
.PP
.Vb 3
\&        $User = $imap->User();
\&        # or:
\&        $imap->User($userid);
.Ve
.PP
Specifies the userid to use when logging into the \s-1IMAP\s0 service. Can be
supplied with the new method call or separately by calling the
\&\fBUser\fR object method.
.PP
Parameters can be set during new method invocation by passing named
parameter/value pairs to the method, or later by calling the
parameter's eponymous object method.
.SH "Status Methods"
.IX Header "Status Methods"
There are several object methods that return the status of the object.
They can be used at any time to check the status of an \fBIMAPClient\fR
object, but are particularly useful for determining the cause of
failure when a connection and login are attempted as part of a single
new method invocation. The status methods are:
.Sh "Escaped_results"
.IX Subsection "Escaped_results"
Example:
	my \f(CW@results\fR = \f(CW$imap\fR\->Escaped_results ;
.PP
The \fBEscaped_results\fR method is almost identical to the \fBHistory\fR
method. Unlike the \fBHistory\fR method, however, server output
transmitted literally will be wrapped in double quotes, with all of the
parentheses, double quotes, backslashes, newlines, and carrage returns
escaped. If called in a scalar context, \fBEscaped_results\fR returns an
array reference rather than an array.
.PP
\&\fBEscaped_results\fR is useful if you are retrieving output and
processing it manually, and you are depending on the above special
characters to delimit the data. It is not useful when retrieving
message contents; use \fBmessage_string\fR or \fBbody_string\fR for that.
.Sh "History"
.IX Subsection "History"
Example:
.PP
.Vb 1
\&        my @history = $imap->History;
.Ve
.PP
The \fBHistory\fR method is almost identical to the Results method.
Unlike the Results method, however, the \s-1IMAP\s0 command that was issued
to create the results being returned is not included in the returned
results. If called in a scalar context, \fBHistory\fR returns an array
reference rather than an array.
.Sh "IsUnconnected"
.IX Subsection "IsUnconnected"
returns a true value if the object is currently in an Unconnected
state.
.Sh "IsConnected"
.IX Subsection "IsConnected"
returns a true value if the object is currently in either a
Connected, Authenticated, or Selected state.
.Sh "IsAuthenticated"
.IX Subsection "IsAuthenticated"
returns a true value if the object is currently in either an
Authenticated or Selected state.
.Sh "IsSelected"
.IX Subsection "IsSelected"
returns a true value if the object is currently in a Selected state.
.Sh "LastError"
.IX Subsection "LastError"
Internally \fBLastError\fR is implemented just like a parameter (as
described in \*(L"Parameters\*(R", above). There is a \fILastError\fR attribute
and an eponymous accessor method which returns the \fILastError\fR text
string describing the last error condition encountered by the server. 
.PP
Note that some errors are more serious than others, so \fILastError\fR's
value is only meaningful if you encounter an error condition that you
don't like. For example, if you use the exists method to see if a
folder exists and the folder does not exist, then an error message will
be recorded in \fILastError\fR even though this is not a particularly
serious error. On the other hand, if you didn't use exists and just
tried to select a non-existing folder, then select would return
\&\f(CW\*(C`undef\*(C'\fR after setting \fILastError\fR to something like \f(CW\*(C`NO SELECT
failed: Can't open mailbox "mailbox": no such mailbox\*(C'\fR. At this point
it would be useful to print out the contents of \fILastError\fR as you
die.
.Sh "LastIMAPCommand"
.IX Subsection "LastIMAPCommand"
New in version 2.0.4, \fBLastIMAPCommand\fR returns the exact \s-1IMAP\s0 command
string to be sent to the server. Useful mainly in constructing error
messages when LastError just isn't enough.
.Sh "Report"
.IX Subsection "Report"
The \fBReport\fR method returns an array containing a history of the \s-1IMAP\s0
session up to the point that \fBReport\fR was called. It is primarily
meant to assist in debugging but can also be used to retrieve raw
output for manual parsing. The value of the Clear parameter controls
how many transactions are in the report. (See the discussion of
Clear in \*(L"Parameters\*(R", above.)
.Sh "Results"
.IX Subsection "Results"
The \fBResults\fR method returns an array containing the results of one
\&\s-1IMAP\s0 client command. It accepts one argument, the transaction number of
the command whose results are to be returned. If transaction number is
unspecified then \fBResults\fR returns the results of the last \s-1IMAP\s0 client
command issued. If called in a scalar context, \fBResults\fR returns an
array reference rather than an array.
.Sh "State"
.IX Subsection "State"
The \fBState\fR method returns a numerical value that indicates the
current status of the \fBIMAPClient\fR object. If invoked with an
argument, it will set the object's state to that value. If invoked
without an argument, it behaves just like Status, below. 
.PP
Normally you will not have to invoke this function. An exception is if
you are bypassing the \fBMail::IMAPClient\fR module's connect and/or
login modules to set up your own connection (say, for example, over
a secure socket), in which case you must manually do what the
connect and login methods would otherwise do for you.
.Sh "Status"
.IX Subsection "Status"
The \fBStatus\fR method returns a numerical value that indicates the
current status of the \fBIMAPClient\fR object. (Not to be confused with
the status method, all lower\-case, which is the implementation of
the \fI\s-1STATUS\s0\fR \s-1IMAP\s0 client command.)
.Sh "Transaction"
.IX Subsection "Transaction"
The \fBTransaction\fR method returns the tag value (or transaction number)
of the last \s-1IMAP\s0 client command.
.SH "Undocumented Methods and Subroutines"
.IX Header "Undocumented Methods and Subroutines"
There are two types of undocumented subroutines and methods. The first
are methods that are not documented because they don't exist, even
though they work just fine. Some of my favorite \fBMail::IMAPClient\fR
methods don't exist but I use them all the time anyway. You can too,
assuming you have your copy of \s-1RFC2060\s0 and its extension \s-1RFC\s0's handy.
(By the way, you do have them handy because I gave them to you. They're
bundled with the \fBMail::IMAPClient\fR distribution in the \fIdocs/\fR
subdirectory.) You should feel free to use any of these undocumented
methods.
.PP
These undocumented methods all use what this document refers to as the
\&\*(L"default method\*(R". See \*(L"Other \s-1IMAP\s0 Client Commands and the Default Object Method\*(R", above, for more information on the default method.
.PP
There are also some undocumented methods and subroutines that actually
do exist. Don't use these! If they aren't documented it's for a reason.
They are either experimental, or intended for use by other
\&\fBMail::IMAPClient\fR methods only, or deprecated, or broken, or all or
none of the above. In no cases can you write programs that use these
methods and assume that these programs will work with the next version
of \fBMail::IMAPClient\fR. I never try to make these undocumented methods
and subroutines backwards compatible because they aren't part of the
documented \s-1API\s0. 
.PP
Occasionally I will add a method and forget to document it; in that
case it's a bug and you should report it. (See \*(L"\s-1REPORTING\s0 \s-1BUGS\s0\*(R",
below.) It is sometimes hard to tell the difference; if in doubt you
may submit a bug report and see what happens! However, don't bothering
submitting bug reports for missing documentation for any method or
subroutine that begins with an underscore (_) character. These methods
are always private and will never be part of the documented interface. 
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
Please feel free to e\-mail the author at \f(CW\*(C`bug\-Mail\-IMAPClient@rt.cpan.org\*(C'\fR
if you encounter any strange behaviors. Don't worry about hurting my 
feelings or sounding like a whiner or anything like that; 
if there's a problem with this module you'll be doing me a favor by
reporting it.  However, I probably won't be able to do much about it if 
you don't include enough information, so please read and follow these
instructions carefully.
.PP
When reporting a bug, please be sure to include the following:
.PP
\&\- As much information about your environment as possible. I especially
need to know which version of Mail::IMAPClient you are running and the
type/version of \s-1IMAP\s0 server to which you are connecting. Your \s-1OS\s0 and
perl verions would be helpful too.
.PP
\&\- As detailed a description of the problem as possible. (What are you
doing? What happens? Have you found a work\-around?)
.PP
\&\- An example script that demonstrates the problem (preferably with as
few lines of code as possible!) and which calls the Mail::IMAPClient's
new method with the Debug parameter set to \*(L"1\*(R". (If this generates
a ridiculous amount of output and you're sure you know where the problem
is, you can create your object with debugging turned off and then 
turn it on later, just before you issue the commands that recreate the 
problem. On the other hand, if you can do this you can probably also 
reduce the program rather than reducing the output, and this would be 
the best way to go under most circumstances.)
.PP
\&\- Output from the example script when it's running with the Debug
parameter turned on. You can edit the output to remove (or preferably
to \*(L"X\*(R" out) sensitive data, such as hostnames, user names, and
passwords, but \s-1PLEASE\s0 do not remove the text that identifies the \s-1TYPE\s0
of \s-1IMAP\s0 server to which you are connecting. Note that in most versions
of \fBMail::IMAPClient\fR, debugging does not print out the user or
password from the login command line. However, if you use some other
means of authenticating then you may need to edit the debugging output
with an eye to security.
.PP
\&\- If something worked in a previous release and doesn't work now,
please tell me which release did work. You don't have to test every
intervening release; just let me know it worked in version x but
doesn't work in version (x+n) or whatever.
.PP
\&\- Don't be surprised if I come back asking for a trace of the problem.
To provide this, you should create a file called \fI.perldb\fR in your
current working directory and include the following line of text in
that file:
.PP
\&\f(CW\*(C`&parse_options("NonStop=1 LineInfo=mail_imapclient_db.out");\*(C'\fR
.PP
For your debugging convenience, a sample .perldb file, which was
randomly assigned the name \fIsample.perldb\fR, is provided in the
distribution.
.PP
Next, without changing your working directory, debug the example script
like this: \f(CW\*(C`perl \-d example_script.pl [ args ]\*(C'\fR
.PP
Note that in these examples, the script that demonstrates your problem
is named \*(L"example_script.pl\*(R" and the trace output will be saved in
\&\*(L"mail_imapclient_db.out\*(R". You should either change these values to suit
your needs, or change your needs to suit these values.
.PP
Bug reports should be mailed to: 
.PP
.Vb 1
\&        bug-Mail-IMAPClient@rt.cpan.org
.Ve
.PP
Please remember to place a \s-1SHORT\s0 description of the problem in the subject
of the message. Please try to be a bit specific; things like \*(L"Bug
in Mail::IMAPClient\*(R" or \*(L"Computer Problem\*(R" won't exactly expedite things
on my end.
.SH "REPORTING THINGS THAT ARE NOT BUGS"
.IX Header "REPORTING THINGS THAT ARE NOT BUGS"
If you have suggestions for extending this functionality of this module, or
if you have a question and you can't find an answer in any of the 
documentation (including the \s-1RFC\s0's, which are included in this distribution
for a reason), then you can e\-mail me at the following address:
.PP
.Vb 1
\&        DJKERNEN@cpan.org
.Ve
.PP
Please note that this address is for questions, suggestions, and other comments
about \fBMail::IMAPClient\fR. It's not for reporting bugs, it's not for general 
correspondence, and it's especially not for selling porn, mortgages, Viagra, 
penis enlargment pills, \s-1DVD\s0 copying software, or anything else.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&        David J. Kernen
\&        The Kernen Consulting Group, Inc
\&        DJKERNEN@cpan.org
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 2
\&   Copyright 1999, 2000, 2001, 2002 The Kernen Group, Inc.
\&   All rights reserved.
.Ve
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either:
.ie n .IP "a) the ""Artistic License"" which comes with this Kit, or" 4
.el .IP "a) the ``Artistic License'' which comes with this Kit, or" 4
.IX Item "a) the Artistic License which comes with this Kit, or"
.PD 0
.IP "b) the \s-1GNU\s0 General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version." 4
.IX Item "b) the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version."
.PD
.PP
This program is distributed in the hope that it will be useful, but
\&\s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0
or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0. See either the \s-1GNU\s0 General Public
License or the Artistic License for more details. All your base are
belong to us.
